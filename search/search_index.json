{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MIDI Scripter","text":"<p>MIDI Scripter is a Python framework for filtering, modifying, routing and any other handling of MIDI, Open Sound Control (OSC), keyboard and mouse input and output.</p> <p>MIDI Scripter listens to input ports and sends incoming messages to subscribed callables such as functions or methods.  These callables, along with other Python code, can send modified or new messages through output ports.  MIDI Scripter can serve as a proxy that filters, transforms and converts incoming messages.</p> <p>In addition, MIDI Scripter features a customizable graphical user interface (GUI)  that provides logging, coding assistance, various controls and indicators to use in the script.</p> <p>All that with no boilerplate and only a few lines of code.</p> <p>An octave transposer with GUI controls in 10 lines of code:</p> <pre><code>from midiscripter import *\n\nmidi_keyboard = MidiIn('MIDI Keyboard')  # GUI will provide you the port names\nproxy_output = MidiOut('To DAW', virtual=True)  # virtual proxy port for output\n\n# GUI widget in a single line\noctave_selector = GuiButtonSelectorH(('-2', '-1', '0', '+1', '+2'), select='0')\n\n@midi_keyboard.subscribe  # decorated function will receive port's messages\ndef transpose(msg: MidiMsg) -&gt; None:\n    if msg.type == MidiType.NOTE_ON or msg.type == MidiType.NOTE_OFF:  # filter\n        msg.data1 += 12 * int(octave_selector.selected_item_text)  # modify\n    proxy_output.send(msg)  # route\n\nif __name__ == '__main__':\n    start_gui()  # opens helpful customizable GUI\n</code></pre> <p>Screenshot with only <code>octave_selector</code> widget enabled:</p> <p></p> <p>Screenshot with service Ports and Log and Message Sender widgets:</p> <p></p> <p>The average latency for the script above is less than 0.25 milliseconds.</p> <p>Currently, MIDI Scripter is at \"beta\" development stage.  It is fully functional but needs more user feedback. </p>"},{"location":"#use-cases","title":"Use cases","text":"<ul> <li>Programming MIDI input/output handling scripts    that may also use OSC, keyboard and mouse input/output.</li> <li>Mapping your MIDI controller in your own custom way,    from simple MIDI message filtering or conversion to mostly anything you can imagine.</li> <li>Controlling Ableton Live with Python, without diving into    it's complex MIDI remote scripting or Max for Live.</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Launch an app or run any Python code with a MIDI message.</li> <li>Show pressed chord description.</li> <li>Control Ableton Live with remote script or AbletonOSC.</li> <li>Make custom mapping overlay on top of Ableton Live built-in MIDI controller integration.</li> <li>Run Python code with Ableton Live clips.</li> <li>Save and load global presets for Ableton Live devices.</li> <li>Add extra banks to MIDI controller.</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>MIDI Scripter has fully documented and type hinted API. Overview and API documentation is available here.</p>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Install Python 3.11+ including pip.</li> <li>Run <code>pip install midiscripter</code>.</li> </ol> <p>Extra steps for Windows:</p> <ol> <li>Enable <code>Add python .exe to PATH</code> option in Python installer.</li> <li>Install loopMIDI for virtual MIDI port support.</li> </ol>"},{"location":"#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Paste the script template into your Python IDE or a plain text editor. Using IDE is recommended.</li> <li>Run the template script directly from the IDE or by <code>python your_script.py</code>.     This will open the GUI, providing information about available ports and incoming input.</li> <li>Ensure that the \u201cShow Unused Ports\u201d button located under the port list is activated.     Enable the checkboxes for any available ports to open them. Monitor the log for incoming messages.</li> <li>Click on the port names and messages in the log or port list to copy their declarations to the clipboard.     You can paste the declarations into your script.</li> <li>Rewrite the template function to achieve desired functionality. Use <code>log('messages')</code> for debugging purposes.</li> <li>Restart the script from the GUI to see how it performs.</li> <li>Develop more complex scripts by utilizing additional inputs, outputs and functions (callables).     Subscribe new callables to input messages using the <code>@input_port.subscribe</code> decorator.</li> </ol>"},{"location":"#license","title":"License","text":"<p>MIDI Scripter assets and code is under LGPL 3.0 license. The code that use it can have any license.</p>"},{"location":"ableton/","title":"Controlling Ableton Live","text":"<p>MIDI Scripter was originally created to overcome some limitations  of Ableton Live without getting into rewriting its complex built-in MIDI remote scripts.</p> <p>MIDI Scripter has two ways to communicate directly with Ableton Live internals.  Both have their own limitations, so some use cases may require to use both.</p>"},{"location":"ableton/#ableton-midi-user-remote-script","title":"Ableton MIDI User Remote Script","text":"<p>The idea behind this method is to use pre-mapped Ableton Live user remote  script and communicate with it using MIDI. </p> <p>It uses the special <code>AbletonIO</code>, <code>AbletonIn</code> and <code>AbletonOut</code>  ports that are essentially proxy MIDI ports. <code>AbletonMsg</code> messages they use are MIDI messages  mapped to <code>AbletonEvent</code>.</p> <p>The user remote script can be installed using action in the <code>Help</code>  section of MIDI Scripter GUI's menubar. After installation the <code>MIDI Scripter</code>  user remote script should be assigned to the proxy ports you use in Ableton  Live settings. The script uses MIDI channel 15.</p> <p>Example: Select armed track script with Ableton MIDI Remote Script</p>"},{"location":"ableton/#abletonosc","title":"AbletonOSC","text":"<p>Another way is to use AbletonOSC  remote script and OSC messages. The AbletonOSC remote script should be installed  to Ableton Live and enabled in its settings.</p> <p>This method doesn't use any special ports or messages.  You should use <code>OscIO</code> or <code>OscIn</code> and <code>OscOut</code> with reference  to AbletonOSC documentation for address and data attributes. </p> <p>AbletonOSC is more capable than the MIDI method in many ways,  but it's current lack of track and clip index updates makes MIDI  the preferred method for simple actions.</p> <p>AbletonOSC listeners send events with index the track/clip had  when the listener was attached to it, while the track/clip  can be already moved to another place in Ableton session. </p> <p>Example: Select armed track script with AbletonOSC</p>"},{"location":"overview/","title":"Overview","text":"<p>MIDI Scripter scripts has 5 main elements:</p> <pre><code>from midiscripter import *\n\n# 1. Ports\nmidi_keyboard = MidiIn('MIDI Keyboard')\nproxy_output = MidiOut('To DAW', virtual=True)\n\n# 2. GUI widgets\noctave_selector = GuiButtonSelectorH(('-2', '-1', '0', '+1', '+2'), select='0')\n\n# 3. Calls\n@midi_keyboard.subscribe\ndef transpose(msg: MidiMsg) -&gt; None:\n\n# 4. Messages\n    if msg.type == MidiType.NOTE_ON or msg.type == MidiType.NOTE_OFF:\n        msg.data1 += 12 * int(octave_selector.selected_item_text)\n    proxy_output.send(msg)\n\n# 5. Starter\nif __name__ == '__main__':\n    start_gui() \n</code></pre>"},{"location":"overview/#1-ports","title":"1. Ports","text":"<p>There are three port types: input, output and input/output (i/o) ports.</p> <p>The i/o port is implemented as a wrapper that combines  input and output ports together and acts like both. </p> <p>Ports are typically declared as <code>port_class(name_or_address)</code> or <code>port_class()</code>  (for those that don't need a name or address). For detailed information  on specific port types, refer to the API documentation.</p> <p>Virtual MIDI ports can be created with <code>MidiIn('Virtual port name', virtual=True)</code>  (installed loopMIDI required for Windows).  Virtual MIDI ports can be used to write proxy scripts like the one above.</p> <p>Port instance declaration is all you need to use the port. The starter function opens all declared ports, input ports start feeding  incoming messages to subscribed callables.</p> <p>Input and i/o ports can subscribe callables with the decorator. </p> <p>Output and i/o ports can send messages with <code>output_port.send(msg)</code>.</p> <p>Available ports:</p> <ul> <li>MIDI</li> <li>OSC</li> <li>Keyboard</li> <li>Mouse</li> <li>Ableton Live Remote</li> <li>File System Events</li> <li>Metronome</li> </ul>"},{"location":"overview/#2-gui-widgets","title":"2. GUI widgets","text":"<p>Declared GUI widgets appear in GUI window opened by  <code>start_gui</code> starter function.</p> <p>Widgets are declared as <code>widget_class(content)</code>.</p> <p>Widget's initial state can be set by keyword arguments specific for widget class (<code>color</code>, <code>select</code>, <code>toggle_state</code>, etc.) like in the example above.</p> <p>Widget's title to show in GUI can be optionally set by the <code>title</code> keyword argument.  Otherwise, widget's content or type is used as a title. The title is also used for widget's position saving.</p> <p>Widget's state can be read or set by reading or changing its properties.</p> <p>For detailed information on how to declare and use specific widgets,  refer to the API documentation.</p> <p>GUI widgets can be rearranged in the window by dragging their titles.  At first run widget layout can be random, but it's easy to arrange it as you want. The GUI will save the layout for each script.</p> <p>GUI widgets can subscribe callables that will receive <code>GuiEventMsg</code> messages.</p> <p>Custom PySide6 widgets can be added to the GUI by <code>add_qwidget(qwidget)</code>  before the starter function run.</p> <p>Available widgets:</p> <ul> <li><code>GuiText</code></li> <li><code>GuiEditableText</code></li> <li><code>GuiButton</code></li> <li><code>GuiToggleButton</code></li> <li><code>GuiButtonSelectorH</code></li> <li><code>GuiButtonSelectorV</code></li> <li><code>GuiListSelector</code></li> <li><code>GuiKnob</code></li> <li><code>GuiSliderH</code></li> <li><code>GuiSliderV</code></li> <li><code>GuiProgressBarH</code></li> <li><code>GuiProgressBarV</code></li> <li><code>GuiWidgetLayout</code></li> </ul>"},{"location":"overview/#3-calls","title":"3. Calls","text":"<p>Input ports and GUI widgets subscribe functions, object methods or anything  callable to call with incoming message object. Callables can have any name,  must accept a message as their only argument or have no arguments at all, and are not expected to return anything.</p> <p>To subscribe a callable to the messages from an input port or a GUI widget, use the <code>@input_port.subscribe</code> decorator. A single callable can be subscribed  to multiple ports by stacking multiple decorators:</p> <pre><code>@input_port_1.subscribe\n@input_port_2.subscribe\ndef do_something(msg: MidiMsg) -&gt; None:\n    log.green('This function receives messages from both ports')\n</code></pre> <p>Callable subscription can have conditions provided as decorator arguments: <code>@input_port.subscribe(conditions)</code>. Conditions can be  message <code>.matches</code> arguments  or a <code>CallOn</code> enum value. Object methods can be subscribed by <code>input_port.subscribe(conditions)(object.method)</code>.</p> <p>MIDI Scripter includes its own logger for debugging or feedback.  Print log messages with <code>log('message')</code> or <code>log.red('colored message')</code>.  The color methods are <code>red</code>, <code>yellow</code>, <code>green</code>, <code>cyan</code>, <code>blue</code> and <code>magenta</code>.</p> <p>Each call runs in its own thread, but all calls run in the same process. So if a call performs some heavy computing, it can increase latency and  jitter for the whole script. It's recommended to move heavy computing out  of the main process with Python's <code>multiprocessing</code> module.</p> <p>Each callable receives its own copy of the input message it can modify  without affecting other calls' work.</p> <p>Getting an exception in a call won't affect other calls' or the script's work. Exception details are printed to log.</p> <p>You can check call execution time statistics in the Ports GUI widget by hovering mouse over a call item.</p>"},{"location":"overview/#4-messages","title":"4. Messages","text":"<p>Messages are data objects produced by input ports or created in the script's code. Messages can be sent with an output port of the corresponding  type.</p> <p>Each message stores the source port/widget instance as <code>source</code> attribute and its creation time in epoch format as <code>ctime</code> attribute.</p> <p>The time since message creation (in milliseconds) can be checked by its <code>age_ms</code> attribute.</p> <p>MIDI message objects attributes meanings depending on MIDI message type:</p> <code>type</code> <code>channel</code> <code>data1</code> <code>data2</code> <code>combined_data</code> <code>MidiType.NOTE_ON</code> Channel(1-16) Note(0-127) Velocity(0-127) useless <code>MidiType.NOTE_OFF</code> Channel(1-16) Note(0-127) Velocity(0-127) useless <code>MidiType.CONTROL_CHANGE</code> Channel(1-16) Controller(0-127) Value(0-127) useless <code>MidiType.POLYTOUCH</code> Channel(1-16) Note(0-127) Pressure(0-127) useless <code>MidiType.AFTERTOUCH</code> Channel(1-16) Pressure(0-127) useless useless <code>MidiType.PROGRAM_CHANGE</code> Channel (1-16) Program(0-127) useless useless <code>MidiType.PITCH_BEND</code> Channel(1-16) useless useless Pitch(0-16383) <code>MidiType.SYSEX</code> Manufacturer ID (ints in tuple) Sub ID(ints in tuple) Data(ints in tuple) Whole message(ints in tuple) <p>The common attribute names and their defaults allows to safely change message's <code>type</code>:</p> <pre><code># This type of message doesn't use the `data2` attribute\n&gt;&gt;&gt; msg = ChannelMsg(MidiType.PROGRAM_CHANGE, 1, 10)\n\n# But it still has the default value for `data2` it doesn't use\n&gt;&gt;&gt; msg.data2\n64\n\n# So when you change its `type` the message is still valid to send\n&gt;&gt;&gt; msg.type = MidiType.CONTROL_CHANGE \n&gt;&gt;&gt; msg\nChannelMsg(MidiType.CONTROL_CHANGE, 1, 10, 64)  \n</code></pre> <p>Other message types are simpler. Check the API documentation for their  description.</p> <p>Available message types:</p> <ul> <li><code>MidiMsg</code> (<code>ChannelMsg</code>, <code>SysexMsg</code>)</li> <li><code>OscMsg</code></li> <li><code>AbletonMsg</code></li> <li><code>KeyMsg</code></li> <li><code>MouseMsg</code></li> <li><code>GuiEventMsg</code></li> <li><code>FileEventMsg</code></li> </ul>"},{"location":"overview/#5-starter","title":"5. Starter","text":"<p>Starter is a function that should be called after ports, widgets and calls are set up. Starter opens all ports, keeps input message listening loops running and handles logging.</p> <p>There are 3 starter functions:</p> <ul> <li><code>start_gui</code> - starts the script with GUI and routes   log messages to its Log widget. The preferred starter.</li> <li><code>start_silent</code> - starts the script with no   logging or GUI. The most efficient.</li> <li><code>start_cli_debug</code> - starts the script with   logging to console. That increases latency and jitter. Use only while   debugging the script with no access to GUI.</li> </ul>"},{"location":"overview/#message-matching","title":"Message matching","text":"<p>Message objects can be filtered within callables by their attribute values as in  the example above, but they also have more powerful  <code>.matches</code> method.</p> <p>This method takes conditions for each message object attribute in the  order of message object's <code>__init__</code>.</p> <p>The matching uses the simplified  schema-like approach:</p> <ol> <li>If the condition is <code>None</code> or omitted, it matches anything.</li> <li>If the condition equals the attribute, it matches the attribute.</li> <li>If the condition is a container (list, tuple) and contains the attribute,  it matches the attribute.</li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <pre><code>&gt;&gt;&gt; msg = MidiMsg(MidiType.NOTE_ON, 1, 61, 80)\n\n&gt;&gt;&gt; msg.matches(\n    (MidiType.NOTE_ON, MidiType.NOTE_OFF),  # only \"note on\" or \"note off\"\n    None,  # any channel\n    range(60, 120)  # note value between 60 and 120\n)  # no velocity value provided - matches any velocity\nTrue\n\n&gt;&gt;&gt; msg.matches(\n    MidiType.NOTE_ON,  # only \"note on\"\n    data2=Not(range(60, 128))  # velocity not in 60 - 128 range\n)  \nFalse\n</code></pre> <p>The matching pattern can be used as arguments for  <code>@input_port_subscribe</code> decorator. Only matching messages will go to calls:</p> <pre><code>@input_port.subscribe(MidiType.SYSEX)\ndef only_sysex(msg: MidiMsg) -&gt; None: \n    log('Only the sysex messages will go here')\n</code></pre> <p>Using <code>subscribe</code> arguments where possible improves the script's efficiency,  since no calls are made for non-matching messages.</p> <p>The one-line filtered message proxy using matching <code>subscribe</code>: <pre><code>MidiIn('MIDI Controller').subscribe(MidiType.SYSEX)(MidiOut('To DAW').send)\n</code></pre></p>"},{"location":"overview/#combining-multiple-scripts","title":"Combining multiple scripts","text":"<p>A single combined script is easier to manage than running multiple scripts in parallel.</p> <p>To combine multiple atomic scripts to run as a single one you can import them.</p> <p>It is possible because port declaration with the same arguments returns  the same port object instance (singleton):</p> <pre><code>&gt;&gt;&gt; MidiIn('Port name') is MidiIn('Port name')\nTrue\n</code></pre> <p>Imported scripts should have their starters in <code>if __name__ == '__main__':</code> clause:</p> <pre><code>from midiscripter import *\n\n# Scripts with starter in `if __name__ == '__main__':` are safe to import \nimport my_first_script\nimport my_second_script\n\nif __name__ == '__main__':\n    # Uses setups from both scripts and runs them as a single script\n    start_gui() \n</code></pre>"},{"location":"api/ableton_msg/","title":"Message","text":""},{"location":"api/ableton_msg/#midiscripter.AbletonEvent","title":"<code>AbletonEvent</code>","text":"<p>               Bases: <code>AttrEnum</code></p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.CUE_VOL","title":"<code>CUE_VOL = 'CUE_VOL'</code>","text":"<p>Cue level control</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.CROSSFADER","title":"<code>CROSSFADER = 'CROSSFADER'</code>","text":"<p>Crossfader control</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.DEVICE_BANK","title":"<code>DEVICE_BANK = 'DEVICE_BANK'</code>","text":"<p>Select device encoder bank by index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.DEVICE_BANK_NEXT","title":"<code>DEVICE_BANK_NEXT = 'DEVICE_BANK_NEXT'</code>","text":"<p>Select next device encoder bank</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.DEVICE_BANK_PREV","title":"<code>DEVICE_BANK_PREV = 'DEVICE_BANK_PREV'</code>","text":"<p>Select previous device encoder bank</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.DEVICE_LOCK","title":"<code>DEVICE_LOCK = 'DEVICE_LOCK'</code>","text":"<p>Device lock (lock \"blue hand\")</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.DEVICE_TOGGLE","title":"<code>DEVICE_TOGGLE = 'DEVICE_TOGGLE'</code>","text":"<p>Toggle selected device on/off</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.ENCODER","title":"<code>ENCODER = 'ENCODER'</code>","text":"<p>Parameters control</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.FORWARD","title":"<code>FORWARD = 'FORWARD'</code>","text":"<p>Fast forward</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.LOOP","title":"<code>LOOP = 'LOOP'</code>","text":"<p>Loop on/off</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.MASTER_SEL","title":"<code>MASTER_SEL = 'MASTER_SEL'</code>","text":"<p>Master track select</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.MASTER_VOL","title":"<code>MASTER_VOL = 'MASTER_VOL'</code>","text":"<p>Master track volume</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.METRONOME","title":"<code>METRONOME = 'METRONOME'</code>","text":"<p>Metronome on/off</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.NUDGE_UP","title":"<code>NUDGE_UP = 'NUDGE_UP'</code>","text":"<p>Tempo Nudge Up</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.NUDGE_DOWN","title":"<code>NUDGE_DOWN = 'NUDGE_DOWN'</code>","text":"<p>Tempo Nudge Down</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.OVERDUB","title":"<code>OVERDUB = 'OVERDUB'</code>","text":"<p>Overdub on/off</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.PLAY","title":"<code>PLAY = 'PLAY'</code>","text":"<p>Global play</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.PUNCH_IN","title":"<code>PUNCH_IN = 'PUNCH_IN'</code>","text":"<p>Punch in</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.PUNCH_OUT","title":"<code>PUNCH_OUT = 'PUNCH_OUT'</code>","text":"<p>Punch out</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.REC","title":"<code>REC = 'REC'</code>","text":"<p>Global record</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.REWIND","title":"<code>REWIND = 'REWIND'</code>","text":"<p>Rewind</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.SESSION_REC","title":"<code>SESSION_REC = 'SESSION_REC'</code>","text":"<p>Session record</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.STOP","title":"<code>STOP = 'STOP'</code>","text":"<p>Global stop</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TAP_TEMPO","title":"<code>TAP_TEMPO = 'TAP_TEMPO'</code>","text":"<p>Tap tempo</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TEMPO_CONTROL","title":"<code>TEMPO_CONTROL = 'TEMPO_CONTROL'</code>","text":"<p>Tempo control</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_ARM","title":"<code>TRACK_ARM = 'TRACK_ARM'</code>","text":"<p>Track record arm by index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_LEFT","title":"<code>TRACK_LEFT = 'TRACK_LEFT'</code>","text":"<p>Track left</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_RIGHT","title":"<code>TRACK_RIGHT = 'TRACK_RIGHT'</code>","text":"<p>Track right</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_MUTE","title":"<code>TRACK_MUTE = 'TRACK_MUTE'</code>","text":"<p>Track On/Off by index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_NEXT_8","title":"<code>TRACK_NEXT_8 = 'TRACK_NEXT_8'</code>","text":"<p>Select next 8 tracks to control with track controls</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_PREV_8","title":"<code>TRACK_PREV_8 = 'TRACK_PREV_8'</code>","text":"<p>Select previous 8 tracks to control with track controls</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_SELECT","title":"<code>TRACK_SELECT = 'TRACK_SELECT'</code>","text":"<p>Track select by index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_SEND_A","title":"<code>TRACK_SEND_A = 'TRACK_SEND_A'</code>","text":"<p>Track Send A</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_SEND_B","title":"<code>TRACK_SEND_B = 'TRACK_SEND_B'</code>","text":"<p>Track Send B</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_SOLO","title":"<code>TRACK_SOLO = 'TRACK_SOLO'</code>","text":"<p>Track solo by index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_STOP","title":"<code>TRACK_STOP = 'TRACK_STOP'</code>","text":"<p>Track clip stop by track index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.TRACK_VOL","title":"<code>TRACK_VOL = 'TRACK_VOL'</code>","text":"<p>Track Volume</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonEvent.UNSUPPORTED","title":"<code>UNSUPPORTED = 'UNSUPPORTED'</code>","text":"<p>Unknown message</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg","title":"AbletonMsg","text":"<pre><code>AbletonMsg(\n    type: AbletonEvent,\n    index_or_value: int | bool = True,\n    value: int | bool = None,\n    *,\n    source: None | AbletonIn = None\n)\n</code></pre> <p>               Bases: <code>Msg</code></p> <p>Ableton Live remote script event message</p> <p>Overloads: <pre><code>AbletonMsg(\n    type: AbletonEvent,\n    index: int,\n    value: int | bool,\n    *,\n    source: 'None | AbletonIn' = None\n)\n</code></pre> <pre><code>AbletonMsg(\n    type: AbletonEvent,\n    value: int | bool,\n    *,\n    source: 'None | AbletonIn' = None\n)\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>type</code>               (<code>AbletonEvent</code>)           \u2013            <p>Ableton Live remote script event</p> </li> <li> <code>index</code>               (<code>int</code>)           \u2013            <p>Track/encoder/device bank index</p> </li> <li> <code>value</code>               (<code>int | bool</code>, default:                   <code>None</code> )           \u2013            <p>Control event value (0-127 or True / False)</p> </li> <li> <code>source</code>               (<code>None | AbletonIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>AbletonIn</code> instance that generated the message</p> </li> </ul>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg.type","title":"type","text":"<pre><code>type: AbletonEvent\n</code></pre> <p>Ableton Live remote script event</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg.index","title":"index","text":"<pre><code>index: None | int = None\n</code></pre> <p>Track/clip/send index</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg.value","title":"value","text":"<pre><code>value: int | bool\n</code></pre> <p>Control event value</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg.source","title":"source","text":"<pre><code>source: None | AbletonIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/ableton_msg/#midiscripter.AbletonMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[AbletonEvent] | AbletonEvent = None,\n    index: None | Container[int] | int = None,\n    value: None | Container[int] | int | bool = None,\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/ableton_port/","title":"Ports","text":"<p>Warning</p> <p>These ports require the special Ableton Live user remote script installed.</p> <p>The remote script can be installed using action in the <code>Help</code>  section of MIDI Scripter GUI's menubar. </p> <p>The <code>MIDI Scripter</code> user remote script should be  assigned to <code>proxy_midi_port_name</code> MIDI ports in Ableton Live settings.</p>"},{"location":"api/ableton_port/#midiscripter.AbletonIO","title":"AbletonIO","text":"<pre><code>AbletonIO(proxy_midi_port_name: str, *, virtual: bool = False)\n</code></pre> <p>               Bases: <code>MidiIO</code></p> <p>Parameters:</p> <ul> <li> <code>port_name</code>               (<code>str</code>)           \u2013            <p>MIDI port name</p> </li> <li> <code>virtual</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create virtual input and output ports</p> </li> <li> <code>loopback</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Immediately send the messages received by the input port with the output port</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonIO.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/ableton_port/#midiscripter.AbletonIO.passthrough_out","title":"passthrough_out","text":"<pre><code>passthrough_out(midi_output: MidiOut) -&gt; None\n</code></pre> <p>Attach <code>MidiOut</code> as a pass-through port to send all incoming messages as soon as they arrive, before sending them to calls. This can greatly reduce latency.</p> <p>Parameters:</p> <ul> <li> <code>midi_output</code>               (<code>MidiOut</code>)           \u2013            <p><code>MidiOut</code> port to use for pass-through</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonIO.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[AbletonEvent] | AbletonEvent = None,\n    index: (\n        None | Container[int, tuple[int, int]] | int | tuple[int, int]\n    ) = None,\n    value: None | Container[int] | int | bool = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to all the wrapped inputs' messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonIO.send","title":"send","text":"<pre><code>send(msg: AbletonMsg | ChannelMsg) -&gt; None\n</code></pre> <p>Send message to Ableton remote script.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>AbletonMsg | ChannelMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonIn","title":"AbletonIn","text":"<pre><code>AbletonIn(proxy_midi_port_name: str, *, virtual: bool = False)\n</code></pre> <p>               Bases: <code>MidiIn</code></p> <p>Receives MIDI messages from Ableton Live remote script and produces <code>AbletonMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>proxy_midi_port_name</code>               (<code>str</code>)           \u2013            <p>The name of proxy MIDI input port enabled in Ableton Live</p> </li> <li> <code>virtual</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create virtual MIDI port</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/ableton_port/#midiscripter.AbletonIn.passthrough_out","title":"passthrough_out","text":"<pre><code>passthrough_out(midi_output: MidiOut) -&gt; None\n</code></pre> <p>Attach <code>MidiOut</code> as a pass-through port to send all incoming messages as soon as they arrive, before sending them to calls. This can greatly reduce latency.</p> <p>Parameters:</p> <ul> <li> <code>midi_output</code>               (<code>MidiOut</code>)           \u2013            <p><code>MidiOut</code> port to use for pass-through</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[AbletonEvent] | AbletonEvent = None,\n    index: (\n        None | Container[int, tuple[int, int]] | int | tuple[int, int]\n    ) = None,\n    value: None | Container[int] | int | bool = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonOut","title":"AbletonOut","text":"<pre><code>AbletonOut(proxy_midi_port_name: str, *, virtual: bool = False)\n</code></pre> <p>               Bases: <code>MidiOut</code></p> <p>Sends <code>AbletonMsg</code> objects as MIDI message to Ableton Live remote script.</p> <p>Parameters:</p> <ul> <li> <code>proxy_midi_port_name</code>               (<code>str</code>)           \u2013            <p>The name of proxy MIDI output port enabled in Ableton Live</p> </li> <li> <code>virtual</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create virtual MIDI port</p> </li> </ul>"},{"location":"api/ableton_port/#midiscripter.AbletonOut.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/ableton_port/#midiscripter.AbletonOut.send","title":"send","text":"<pre><code>send(msg: AbletonMsg | ChannelMsg) -&gt; None\n</code></pre> <p>Send message to Ableton remote script.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>AbletonMsg | ChannelMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/base_call/","title":"Extra Call Conditions","text":""},{"location":"api/base_call/#midiscripter.base.port_base.CallOn","title":"CallOn","text":"<p>               Bases: <code>StrEnum</code></p> <p>Special conditions to use as <code>@input_port.subscribe(condition)</code></p>"},{"location":"api/base_call/#midiscripter.base.port_base.CallOn.NOT_MATCHED_BY_ANY_CALL","title":"NOT_MATCHED_BY_ANY_CALL","text":"<pre><code>NOT_MATCHED_BY_ANY_CALL = 'NOT MATCHED BY ANY CALLS'\n</code></pre> <p>Call when a message is not matched by any other call</p>"},{"location":"api/base_call/#midiscripter.base.port_base.CallOn.PORT_INIT","title":"PORT_INIT","text":"<pre><code>PORT_INIT = 'PORT INIT'\n</code></pre> <p>Call after port is initially opened</p>"},{"location":"api/base_gui_widget/","title":"GUI Widget","text":""},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget","title":"GuiWidget","text":"<pre><code>GuiWidget(\n    content: str | Sequence[str] | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    value: str | int | bool | None = None,\n    select: int | str | None = None,\n    toggle_state: bool | None = None,\n    range: tuple[int, int] | None = None,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWindowItem</code>, <code>Subscribable</code></p> <p>GUI windows widget which can have calls subscribed to it's <code>GuiEventMsg</code>.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Widget's text or text for its items</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Color as color name or RGB tuple</p> </li> <li> <code>value</code>               (<code>str | int | bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Initial value</p> </li> <li> <code>select</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Preselected item</p> </li> <li> <code>toggle_state</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Initial toggle state</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.value","title":"value","text":"<pre><code>value: str | int | bool | None\n</code></pre> <p>Widget's value / selected item text</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.selected_item_text","title":"selected_item_text","text":"<pre><code>selected_item_text: str | None\n</code></pre> <p>Widget's currently selected item's text</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.selected_item_index","title":"selected_item_index","text":"<pre><code>selected_item_index: int | None\n</code></pre> <p>Widget's currently selected item's index</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.toggle_state","title":"toggle_state","text":"<pre><code>toggle_state: bool | None\n</code></pre> <p>Toggle state</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.range","title":"range","text":"<pre><code>range: tuple[int, int] | None\n</code></pre> <p>Value range</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.select","title":"select","text":"<pre><code>select(selection: int | str) -&gt; None\n</code></pre> <p>Select widget's item</p> <p>Parameters:</p> <ul> <li> <code>selection</code>               (<code>int | str</code>)           \u2013            <p>Index or text of item to select</p> </li> </ul>"},{"location":"api/base_gui_widget/#midiscripter.gui.gui_widgets.gui_widget_base.GuiWidget.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/base_msg/","title":"Message","text":""},{"location":"api/base_msg/#midiscripter.base.msg_base.Msg","title":"Msg","text":"<pre><code>Msg(type: str, source: Input | None = None)\n</code></pre> <p>The data object generated by input port that is sent as an argument to its subscribed calls and can be sent with an output port</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Input | None</code>, default:                   <code>None</code> )           \u2013            <p>Input port instance that generated the message</p> </li> </ul>"},{"location":"api/base_msg/#midiscripter.base.msg_base.Msg.type","title":"type","text":"<pre><code>type: str = type\n</code></pre> <p>Message type description for filtering and representation</p>"},{"location":"api/base_msg/#midiscripter.base.msg_base.Msg.source","title":"source","text":"<pre><code>source: Input | None = source\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/base_msg/#midiscripter.base.msg_base.Msg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/base_msg/#midiscripter.base.msg_base.Msg.matches","title":"matches","text":"<pre><code>matches(*conditions_args, **conditions_kwargs) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/base_ports/","title":"Ports","text":""},{"location":"api/base_ports/#midiscripter.base.port_base.MultiPort","title":"MultiPort","text":"<pre><code>MultiPort(\n    uid: str,\n    input_ports: Input | Sequence[Input],\n    output_ports: Output | Sequence[Output],\n)\n</code></pre> <p>               Bases: <code>Port</code></p> <p>Multiport wrapper class. Combines <code>Input</code> and <code>Output</code> ports to a single i/o port.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>str</code>)           \u2013            <p>Port's unique ID</p> </li> <li> <code>input_ports</code>               (<code>Input | Sequence[Input]</code>)           \u2013            <p>input ports to wrap</p> </li> <li> <code>output_ports</code>               (<code>Output | Sequence[Output]</code>)           \u2013            <p>output ports to wrap</p> </li> </ul>"},{"location":"api/base_ports/#midiscripter.base.port_base.MultiPort.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/base_ports/#midiscripter.base.port_base.MultiPort.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    *msg_matches_args: None | Container[Any] | Any,\n    **msg_matches_kwargs: (str, None | Container[Any] | Any)\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to all the wrapped inputs' messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/base_ports/#midiscripter.base.port_base.MultiPort.send","title":"send","text":"<pre><code>send(msg: Msg) -&gt; None\n</code></pre> <p>Send message using wrapped output ports</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>Msg</code>)           \u2013            <p>Message to send.</p> </li> </ul>"},{"location":"api/base_ports/#midiscripter.base.port_base.Input","title":"Input","text":"<pre><code>Input(uid: Hashable | None = None)\n</code></pre> <p>               Bases: <code>Subscribable</code>, <code>Port</code></p> <p>Input port base class</p>"},{"location":"api/base_ports/#midiscripter.base.port_base.Input.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/base_ports/#midiscripter.base.port_base.Input.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    *msg_matches_args: None | Container[Any] | Any,\n    **msg_matches_kwargs: (str, None | Container[Any] | Any)\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/base_ports/#midiscripter.base.port_base.Output","title":"Output","text":"<pre><code>Output(uid: Hashable | None = None)\n</code></pre> <p>               Bases: <code>Port</code></p> <p>Output port base class</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Port's unique ID</p> </li> </ul>"},{"location":"api/base_ports/#midiscripter.base.port_base.Output.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/base_ports/#midiscripter.base.port_base.Output.send","title":"send","text":"<pre><code>send(msg: Msg) -&gt; None\n</code></pre> <p>Send message using the output port.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>Msg</code>)           \u2013            <p>Message to send.</p> </li> </ul> Notes <p>Supposed to be overridden in subclasses. Should use <code>self._validate_msg_send(msg)</code> before sending and <code>log._msg_sent(self, msg)</code> after.</p>"},{"location":"api/base_ports/#midiscripter.base.port_base.Port","title":"Port","text":"<pre><code>Port(uid: Hashable | None = None)\n</code></pre> <p>Port base class.</p> Notes <p>Port declarations with the same arguments will return the same instance port (singleton).</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Port's unique ID</p> </li> </ul>"},{"location":"api/base_ports/#midiscripter.base.port_base.Port.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/fs_event_msg/","title":"Message","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEvent","title":"<code>FileEvent</code>","text":"<p>               Bases: <code>AttrEnum</code></p> <p>File event message type enumerator to use as <code>FileEventMsg</code> <code>type</code> attribute</p>"},{"location":"api/fs_event_msg/#midiscripter.FileEvent.MOVED","title":"<code>MOVED = 'MOVED'</code>","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEvent.DELETED","title":"<code>DELETED = 'DELETED'</code>","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEvent.CREATED","title":"<code>CREATED = 'CREATED'</code>","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEvent.MODIFIED","title":"<code>MODIFIED = 'MODIFIED'</code>","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEvent.CLOSED","title":"<code>CLOSED = 'CLOSED'</code>","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEvent.OPENED","title":"<code>OPENED = 'OPENED'</code>","text":""},{"location":"api/fs_event_msg/#midiscripter.FileEventMsg","title":"FileEventMsg","text":"<pre><code>FileEventMsg(\n    type: FileEvent | str, path: Path, *, source: None | FileEventIn = None\n)\n</code></pre> <p>               Bases: <code>Msg</code></p> <p>Parameters:</p> <ul> <li> <code>type</code>               (<code>FileEvent | str</code>)           \u2013            <p>File event type</p> </li> <li> <code>path</code>               (<code>Path</code>)           \u2013            <p>File path</p> </li> <li> <code>source</code>               (<code>None | FileEventIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>FileEventIn</code> instance that generated the message</p> </li> </ul>"},{"location":"api/fs_event_msg/#midiscripter.FileEventMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/fs_event_msg/#midiscripter.FileEventMsg.type","title":"type","text":"<pre><code>type: FileEvent = type\n</code></pre> <p>File event type</p>"},{"location":"api/fs_event_msg/#midiscripter.FileEventMsg.path","title":"path","text":"<pre><code>path: Path = path\n</code></pre> <p>File path of event</p>"},{"location":"api/fs_event_msg/#midiscripter.FileEventMsg.source","title":"source","text":"<pre><code>source: None | FileEventIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/fs_event_msg/#midiscripter.FileEventMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[FileEvent] | FileEvent | str = None,\n    path: None | Container[Path] | Path = None,\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/fs_port/","title":"Port","text":""},{"location":"api/fs_port/#midiscripter.FileEventIn","title":"FileEventIn","text":"<pre><code>FileEventIn(path: str | Path, recursive: bool = False)\n</code></pre> <p>               Bases: <code>Input</code>, <code>FileSystemEventHandler</code></p> <p>File system events input port. Watches file/directory modifications. Produces <code>FileEventMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>File/directory path to watch</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p><code>True</code> to watch directory path recursively</p> </li> </ul>"},{"location":"api/fs_port/#midiscripter.FileEventIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/fs_port/#midiscripter.FileEventIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[FileEvent] | FileEvent | str = None,\n    path: None | Container[Path] | Path = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_buttons/","title":"Buttons","text":""},{"location":"api/gui_buttons/#midiscripter.GuiButton","title":"GuiButton","text":"<pre><code>GuiButton(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>Simple button widget</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Button text</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Button text color as color name or RGB tuple</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiButton.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButton.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButton.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButton.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButton.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton","title":"GuiToggleButton","text":"<pre><code>GuiToggleButton(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    toggle_state: bool | None = False,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>Toggleable button</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Button text</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Button text color as color name or RGB tuple</p> </li> <li> <code>toggle_state</code>               (<code>bool | None</code>, default:                   <code>False</code> )           \u2013            <p>Button initial toggle state</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton.toggle_state","title":"toggle_state","text":"<pre><code>toggle_state: bool | None\n</code></pre> <p>Toggle state</p>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_buttons/#midiscripter.GuiToggleButton.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH","title":"GuiButtonSelectorH","text":"<pre><code>GuiButtonSelectorH(\n    content: Sequence[str] | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    select: int | str | None = None,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>Button group to select value, horizontal layout</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Buttons' texts</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Selector button's text color as color name or RGB tuple</p> </li> <li> <code>select</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>text or index of button to select initially</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.selected_item_text","title":"selected_item_text","text":"<pre><code>selected_item_text: str | None\n</code></pre> <p>Widget's currently selected item's text</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.selected_item_index","title":"selected_item_index","text":"<pre><code>selected_item_index: int | None\n</code></pre> <p>Widget's currently selected item's index</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorH.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV","title":"GuiButtonSelectorV","text":"<pre><code>GuiButtonSelectorV(\n    content: Sequence[str] | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    select: int | str | None = None,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>Button group to select value, vertical layout</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Buttons' texts</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Selector button's text color as color name or RGB tuple</p> </li> <li> <code>select</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>text or index of button to select initially</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.selected_item_text","title":"selected_item_text","text":"<pre><code>selected_item_text: str | None\n</code></pre> <p>Widget's currently selected item's text</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.selected_item_index","title":"selected_item_index","text":"<pre><code>selected_item_index: int | None\n</code></pre> <p>Widget's currently selected item's index</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_buttons/#midiscripter.GuiButtonSelectorV.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_layout/","title":"Layout","text":""},{"location":"api/gui_layout/#midiscripter.GuiWidgetLayout","title":"GuiWidgetLayout","text":"<pre><code>GuiWidgetLayout(\n    *rows: Sequence[GuiWidget | GuiWidgetLayout | None | Sequence],\n    spacing: int = 6,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWindowItem</code></p> <p>Layout for grouping and positioning widgets</p> <p>Parameters:</p> <ul> <li> <code>rows</code>               (<code>Sequence[GuiWidget | GuiWidgetLayout | None | Sequence]</code>, default:                   <code>()</code> )           \u2013            <p>A tuple of items to put in a row.   Items can be widgets, layouts, <code>None</code> for spacers or Sequences (list, tuple)   of all the above. If item is a Sequence, it's a column of items in the Sequence.   To stretch the widget multiply it by the stretch multiplier: <code>gui_widget_obj * 2</code>.</p> </li> <li> <code>spacing</code>               (<code>int</code>, default:                   <code>6</code> )           \u2013            <p>space between layout items</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by type if <code>None</code></p> </li> </ul> Example <p><pre><code># 2 rows x 1 column\nGuiWidgetLayout('2 x 1', row1_col1,\n                         row2_col1)\n</code></pre> <pre><code># 1 row x 2 columns\nGuiWidgetLayout('1 x 2', [row1_col1, row1_col2])\n</code></pre> <pre><code># 1 row x 3 columns with the spacer as the second and one third one widget stretched\nGuiWidgetLayout('1 x 2', [row1_col1, None, row1_col3 * 2])\n</code></pre> <pre><code># 2 rows x 2 columns\nGuiWidgetLayout('2 x 2', [row1_col1, row1_col2],\n                         [row2_col1, row2_col2])\n</code></pre> <pre><code># 2 x 2 with second row span\nGuiWidgetLayout('row span', [row1_col1, row1_col2],\n                                  row2_span)\n</code></pre> <pre><code># 2 x 2 with column span\nGuiWidgetLayout('column span', [col1_span, [row1_col2,\n                                            row2_col2]])\n</code></pre></p> Note <p>Calls can't be subscribed to <code>GuiWidgetLayout</code>. Subscribe calls to widgets instead.</p>"},{"location":"api/gui_list/","title":"List Selector","text":""},{"location":"api/gui_list/#midiscripter.GuiListSelector","title":"GuiListSelector","text":"<pre><code>GuiListSelector(\n    content: Sequence[str] | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    select: int | str | None = None,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>List of text items to select value</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Items' texts</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Text color as color name or RGB tuple</p> </li> <li> <code>select</code>               (<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Text or index of item to select initially</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.selected_item_text","title":"selected_item_text","text":"<pre><code>selected_item_text: str | None\n</code></pre> <p>Widget's currently selected item's text</p>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.selected_item_index","title":"selected_item_index","text":"<pre><code>selected_item_index: int | None\n</code></pre> <p>Widget's currently selected item's index</p>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_list/#midiscripter.GuiListSelector.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_msg/","title":"GUI Event Message","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent","title":"<code>GuiEvent</code>","text":"<p>               Bases: <code>AttrEnum</code></p> <p>GUI event type enumerator to use as <code>GuiEventMsg</code> <code>type</code> attribute</p>"},{"location":"api/gui_msg/#midiscripter.GuiEvent.CONTENT_SET","title":"<code>CONTENT_SET = 'CONTENT_SET'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent.COLOR_SET","title":"<code>COLOR_SET = 'COLOR_SET'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent.RANGE_SET","title":"<code>RANGE_SET = 'RANGE_SET'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent.TRIGGERED","title":"<code>TRIGGERED = 'TRIGGERED'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent.TOGGLED","title":"<code>TOGGLED = 'TOGGLED'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent.SELECTED","title":"<code>SELECTED = 'SELECTED'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEvent.VALUE_CHANGED","title":"<code>VALUE_CHANGED = 'VALUE_CHANGED'</code>","text":""},{"location":"api/gui_msg/#midiscripter.GuiEventMsg","title":"GuiEventMsg","text":"<pre><code>GuiEventMsg(\n    type: GuiEvent,\n    data: str | int | bool | Sequence | None = None,\n    *,\n    source: None | GuiWidget = None\n)\n</code></pre> <p>               Bases: <code>Msg</code></p> <p>GUI interaction message produced by GUI widget</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Input | None</code>, default:                   <code>None</code> )           \u2013            <p>Input port instance that generated the message</p> </li> </ul>"},{"location":"api/gui_msg/#midiscripter.GuiEventMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/gui_msg/#midiscripter.GuiEventMsg.type","title":"type","text":"<pre><code>type: GuiEvent = type\n</code></pre> <p>GUI event type</p>"},{"location":"api/gui_msg/#midiscripter.GuiEventMsg.data","title":"data","text":"<pre><code>data: str | int | bool | Sequence | None = data\n</code></pre> <p>New value set by event.</p> <p>Data meaning for event types: TRIGGERED - None CONTENT_SET - New content COLOR_SET - New text color TOGGLED - New toggle state SELECTED - Selected item text VALUE_CHANGED - New value RANGE_SET - New value range</p>"},{"location":"api/gui_msg/#midiscripter.GuiEventMsg.source","title":"source","text":"<pre><code>source: None | GuiWidget\n</code></pre> <p><code>GuiWidget</code> instance that generated the message</p>"},{"location":"api/gui_msg/#midiscripter.GuiEventMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/gui_sliders/","title":"Knob, Sliders and Bars","text":""},{"location":"api/gui_sliders/#midiscripter.GuiKnob","title":"GuiKnob","text":"<pre><code>GuiKnob(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    value: int = 0,\n    range: tuple[int, int] = (0, 100),\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>_GuiSliderWidgetBase</code></p> <p>Knob to set value</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Knob label</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Knob color as color name or RGB tuple</p> </li> <li> <code>value</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Initial value</p> </li> <li> <code>range</code>               (<code>tuple[int, int]</code>, default:                   <code>(0, 100)</code> )           \u2013            <p>Knob value range</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.value","title":"value","text":"<pre><code>value: str | int | bool | None\n</code></pre> <p>Widget's value / selected item text</p>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.range","title":"range","text":"<pre><code>range: tuple[int, int] | None\n</code></pre> <p>Value range</p>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_sliders/#midiscripter.GuiKnob.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV","title":"GuiSliderV","text":"<pre><code>GuiSliderV(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    value: int = 0,\n    range: tuple[int, int] = (0, 100),\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>_GuiSliderWidgetBase</code></p> <p>Vertical slider to set value</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Slider label</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Slider handle color as color name or RGB tuple</p> </li> <li> <code>value</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Initial value</p> </li> <li> <code>range</code>               (<code>tuple[int, int]</code>, default:                   <code>(0, 100)</code> )           \u2013            <p>Slider value range</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.value","title":"value","text":"<pre><code>value: str | int | bool | None\n</code></pre> <p>Widget's value / selected item text</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.range","title":"range","text":"<pre><code>range: tuple[int, int] | None\n</code></pre> <p>Value range</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderV.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH","title":"GuiSliderH","text":"<pre><code>GuiSliderH(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    value: int = 0,\n    range: tuple[int, int] = (0, 100),\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>_GuiSliderWidgetBase</code></p> <p>Horizontal slider to set value</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Slider label</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Slider handle color as color name or RGB tuple</p> </li> <li> <code>value</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Initial value</p> </li> <li> <code>range</code>               (<code>tuple[int, int]</code>, default:                   <code>(0, 100)</code> )           \u2013            <p>Slider value range</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.value","title":"value","text":"<pre><code>value: str | int | bool | None\n</code></pre> <p>Widget's value / selected item text</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.range","title":"range","text":"<pre><code>range: tuple[int, int] | None\n</code></pre> <p>Value range</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_sliders/#midiscripter.GuiSliderH.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV","title":"GuiProgressBarV","text":"<pre><code>GuiProgressBarV(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    value: int = 0,\n    range: tuple[int, int] = (0, 100),\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>_GuiSliderWidgetBase</code></p> <p>Horizontal slider to set value</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Progress bar label</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Progress color as color name or RGB tuple</p> </li> <li> <code>value</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Initial value</p> </li> <li> <code>range</code>               (<code>tuple[int, int]</code>, default:                   <code>(0, 100)</code> )           \u2013            <p>Progress bar value range</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.value","title":"value","text":"<pre><code>value: str | int | bool | None\n</code></pre> <p>Widget's value / selected item text</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.range","title":"range","text":"<pre><code>range: tuple[int, int] | None\n</code></pre> <p>Value range</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarV.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH","title":"GuiProgressBarH","text":"<pre><code>GuiProgressBarH(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    value: int = 0,\n    range: tuple[int, int] = (0, 100),\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>_GuiSliderWidgetBase</code></p> <p>Horizontal slider to set value</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Progress bar label</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Progress color as color name or RGB tuple</p> </li> <li> <code>value</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Initial value</p> </li> <li> <code>range</code>               (<code>tuple[int, int]</code>, default:                   <code>(0, 100)</code> )           \u2013            <p>Progress bar value range</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.value","title":"value","text":"<pre><code>value: str | int | bool | None\n</code></pre> <p>Widget's value / selected item text</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.range","title":"range","text":"<pre><code>range: tuple[int, int] | None\n</code></pre> <p>Value range</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_sliders/#midiscripter.GuiProgressBarH.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_text/","title":"Text","text":""},{"location":"api/gui_text/#midiscripter.GuiText","title":"GuiText","text":"<pre><code>GuiText(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    toggle_state: bool = True,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>Text widget. Goes grey on toggle off.</p> Tip <p>Use <code>GuiText('\u2b24', color='green')</code> for a toggleable \"LED indicator\".</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Widget's text</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Text color as color name or RGB tuple</p> </li> <li> <code>toggle_state</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>False to \"grey out\" text</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_text/#midiscripter.GuiText.content","title":"content","text":"<pre><code>content: Any | tuple[Any, ...]\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_text/#midiscripter.GuiText.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_text/#midiscripter.GuiText.toggle_state","title":"toggle_state","text":"<pre><code>toggle_state: bool | None\n</code></pre> <p>Toggle state</p>"},{"location":"api/gui_text/#midiscripter.GuiText.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_text/#midiscripter.GuiText.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: QWidget | WrappedQWidgetMixin\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_text/#midiscripter.GuiText.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/gui_text/#midiscripter.GuiEditableText","title":"GuiEditableText","text":"<pre><code>GuiEditableText(\n    content: str | None = None,\n    *,\n    color: str | tuple[int, int, int] | None = None,\n    toggle_state: bool = True,\n    title: str | None = None\n)\n</code></pre> <p>               Bases: <code>GuiWidget</code></p> <p>Editable text widget</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Widget's text</p> </li> <li> <code>color</code>               (<code>str | tuple[int, int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Text color as color name or RGB tuple</p> </li> <li> <code>toggle_state</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>False to disable and \"grey out\" text</p> </li> <li> <code>title</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Title for dock widget and position saving, set by content or type if <code>None</code></p> </li> </ul>"},{"location":"api/gui_text/#midiscripter.GuiEditableText.content","title":"content","text":"<pre><code>content: str\n</code></pre> <p>Widget's text or text for its items</p>"},{"location":"api/gui_text/#midiscripter.GuiEditableText.color","title":"color","text":"<pre><code>color: str | tuple[int, int, int] | None\n</code></pre> <p>Color as color name or RGB tuple</p>"},{"location":"api/gui_text/#midiscripter.GuiEditableText.toggle_state","title":"toggle_state","text":"<pre><code>toggle_state: bool | None\n</code></pre> <p>Toggle state</p>"},{"location":"api/gui_text/#midiscripter.GuiEditableText.is_visible","title":"is_visible","text":"<pre><code>is_visible: bool\n</code></pre> <p>Widget is currently visible</p>"},{"location":"api/gui_text/#midiscripter.GuiEditableText.qt_widget","title":"qt_widget","text":"<pre><code>qt_widget: AdaptableLineEditWidget\n</code></pre> <p>Wrapped <code>PySide6</code> <code>QWidget</code> that can be altered for extra customization</p>"},{"location":"api/gui_text/#midiscripter.GuiEditableText.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[GuiEvent] | GuiEvent = None,\n    data: None | Container | str | int | bool | Sequence = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/key_msg/","title":"Message","text":""},{"location":"api/key_msg/#midiscripter.KeyEvent","title":"<code>KeyEvent</code>","text":"<p>               Bases: <code>AttrEnum</code></p> <p>Keyboard event message type enumerator to use as <code>KeyMsg</code> <code>type</code> attribute</p>"},{"location":"api/key_msg/#midiscripter.KeyEvent.PRESS","title":"<code>PRESS = 'PRESS'</code>","text":""},{"location":"api/key_msg/#midiscripter.KeyEvent.RELEASE","title":"<code>RELEASE = 'RELEASE'</code>","text":""},{"location":"api/key_msg/#midiscripter.KeyEvent.TAP","title":"<code>TAP = 'TAP'</code>","text":"<p>Key press and release. Isn't assigned by <code>KeyIn</code> but can be sent with <code>KeyOut</code></p>"},{"location":"api/key_msg/#midiscripter.KeyMsg","title":"KeyMsg","text":"<pre><code>KeyMsg(\n    type: KeyEvent,\n    shortcut_or_keycodes: str | Iterable[Key],\n    *,\n    source: None | KeyIn = None\n)\n</code></pre> <p>               Bases: <code>Msg</code></p> <p>Keyboard event message</p> <p>Parameters:</p> <ul> <li> <code>type</code>               (<code>KeyEvent</code>)           \u2013            <p>Keyboard event type</p> </li> <li> <code>shortcut_or_keycodes</code>               (<code>str | Iterable[Key]</code>)           \u2013            <p>keyboard shortcut description or event key codes</p> </li> <li> <code>source</code>               (<code>None | KeyIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>KeyIn</code> instance that generated the message</p> </li> </ul> Tip <p>Use log to get the shortcuts you need</p>"},{"location":"api/key_msg/#midiscripter.KeyMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/key_msg/#midiscripter.KeyMsg.type","title":"type","text":"<pre><code>type: KeyEvent\n</code></pre> <p>Keyboard event type</p>"},{"location":"api/key_msg/#midiscripter.KeyMsg.keycodes","title":"keycodes","text":"<pre><code>keycodes: list[Key]\n</code></pre> <p>Keycodes in the order they were pressed. Use when pressing order matters.</p>"},{"location":"api/key_msg/#midiscripter.KeyMsg.source","title":"source","text":"<pre><code>source: None | KeyIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/key_msg/#midiscripter.KeyMsg.shortcut","title":"shortcut","text":"<pre><code>shortcut: str\n</code></pre> <p>Keyboard shortcut description like <code>'ctrl+shift+t'</code>. Stays the same for any key pressing order.</p>"},{"location":"api/key_msg/#midiscripter.KeyMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[KeyEvent] | KeyEvent = None,\n    shortcut: None | Container[str] | str = None,\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/key_port/","title":"Ports","text":""},{"location":"api/key_port/#midiscripter.KeyIO","title":"KeyIO","text":"<pre><code>KeyIO(*, supress_input: bool = False)\n</code></pre> <p>               Bases: <code>MultiPort</code></p> <p>Keyboard input/output port that combines <code>KeyIn</code> and <code>KeyOut</code> ports. Produces and sends <code>KeyMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>supress_input</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Prevent the input events from being passed to the rest of the system</p> </li> </ul> Warning <p>Use <code>supress_input</code> with caution! You'll lose the keyboard input unless you're proxying it to an output port.</p>"},{"location":"api/key_port/#midiscripter.KeyIO.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/key_port/#midiscripter.KeyIO.pressed_keys","title":"pressed_keys","text":"<pre><code>pressed_keys: list[Key]\n</code></pre> <p>Currently pressed keys</p>"},{"location":"api/key_port/#midiscripter.KeyIO.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[KeyEvent] | KeyEvent = None,\n    shortcut: None | Container[str] | str = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to all the wrapped inputs' messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/key_port/#midiscripter.KeyIO.send","title":"send","text":"<pre><code>send(msg: KeyMsg) -&gt; None\n</code></pre> <p>Send the keyboard input.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>KeyMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/key_port/#midiscripter.KeyIO.type_in","title":"type_in","text":"<pre><code>type_in(string_to_type: str) -&gt; None\n</code></pre> <p>Type in the text as a keyboard</p>"},{"location":"api/key_port/#midiscripter.KeyIn","title":"KeyIn","text":"<pre><code>KeyIn(*, supress_input: bool = False)\n</code></pre> <p>               Bases: <code>Input</code></p> <p>Keyboard input port. Produces <code>KeyMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>supress_input</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Prevent the input events from being passed to the rest of the system</p> </li> </ul> Warning <p>Use <code>supress_input</code> with caution! You'll lose the keyboard input unless you're proxying it to an output port.</p>"},{"location":"api/key_port/#midiscripter.KeyIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/key_port/#midiscripter.KeyIn.pressed_keys","title":"pressed_keys","text":"<pre><code>pressed_keys: list[Key]\n</code></pre> <p>Currently pressed keys</p>"},{"location":"api/key_port/#midiscripter.KeyIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[KeyEvent] | KeyEvent = None,\n    shortcut: None | Container[str] | str = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/key_port/#midiscripter.KeyOut","title":"KeyOut","text":"<pre><code>KeyOut()\n</code></pre> <p>               Bases: <code>Output</code></p> <p>Keyboard output port. Sends <code>KeyMsg</code> objects.</p>"},{"location":"api/key_port/#midiscripter.KeyOut.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/key_port/#midiscripter.KeyOut.send","title":"send","text":"<pre><code>send(msg: KeyMsg) -&gt; None\n</code></pre> <p>Send the keyboard input.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>KeyMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/key_port/#midiscripter.KeyOut.type_in","title":"type_in","text":"<pre><code>type_in(string_to_type: str) -&gt; None\n</code></pre> <p>Type in the text as a keyboard</p>"},{"location":"api/logging/","title":"Logging","text":""},{"location":"api/logging/#log","title":"log","text":"<p>Prints log messages to GUI Log widget or console. Can print messages in different text colors and highlight object representations.</p> Example <p><code>log('message')</code> for new log entry</p> <p><code>log.red('red message')</code> for log entry printed in red color</p> <p><code>log('{call} received {msg}', call=call_function, msg=some_msg)</code> for log entry with highlighted object representations.</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.__call__","title":"__call__","text":"<pre><code>__call__(text: str | Any, *args: Any, **kwargs: Any)\n</code></pre> <p>Print log message.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str | Any</code>)           \u2013            <p>Log entry to print. Use <code>.format</code> style string to insert kwargs</p> </li> <li> <code>args</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Optional arguments to <code>.format</code> text with</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Optional arguments to <code>.format</code> text with</p> </li> </ul> <p>inputs, outputs, messages and callable arguments are highlighted.</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.red","title":"red","text":"<pre><code>red(text: str | Any, *args, **kwargs) -&gt; None\n</code></pre> <p>Print red log message</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.yellow","title":"yellow","text":"<pre><code>yellow(text: str | Any, *args, **kwargs) -&gt; None\n</code></pre> <p>Print yellow log message</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.green","title":"green","text":"<pre><code>green(text: str | Any, *args, **kwargs) -&gt; None\n</code></pre> <p>Print green log message</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.cyan","title":"cyan","text":"<pre><code>cyan(text: str | Any, *args, **kwargs) -&gt; None\n</code></pre> <p>Print cyan log message</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.blue","title":"blue","text":"<pre><code>blue(text: str | Any, *args, **kwargs) -&gt; None\n</code></pre> <p>Print blue log message</p>"},{"location":"api/logging/#midiscripter.logger.log_obj.Log.magenta","title":"magenta","text":"<pre><code>magenta(text: str | Any, *args, **kwargs) -&gt; None\n</code></pre> <p>Print magenta log message</p>"},{"location":"api/metronome_port/","title":"Metronome","text":""},{"location":"api/metronome_port/#midiscripter.MetronomeIn","title":"MetronomeIn","text":"<pre><code>MetronomeIn(\n    name_or_bpm: str | float,\n    bpm: float = 60,\n    *,\n    msg_to_send: Msg = Msg(\"Click\")\n)\n</code></pre> <p>               Bases: <code>Input</code></p> <p>The input port that sends messages with set interval</p> Notes <p><code>Metronome</code> sets extra <code>bpm</code> and <code>number</code> attributes to any message it sends</p> <p>Overloads: <pre><code>MetronomeIn(name: str, bpm: float = 60, *, msg_to_send: Msg = Msg('Click'))\n</code></pre> <pre><code>MetronomeIn(bpm: float, *, msg_to_send: Msg = Msg('Click'))\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Metronome name</p> </li> <li> <code>bpm</code>               (<code>float</code>, default:                   <code>60</code> )           \u2013            <p>Message sending interval in beats per minute</p> </li> <li> <code>msg_to_send</code>               (<code>Msg</code>, default:                   <code>Msg('Click')</code> )           \u2013            <p>Message the port will send</p> </li> </ul>"},{"location":"api/metronome_port/#midiscripter.MetronomeIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/metronome_port/#midiscripter.MetronomeIn.bpm","title":"bpm","text":"<pre><code>bpm: float\n</code></pre> <p>Message sending interval in beats per minute.</p>"},{"location":"api/metronome_port/#midiscripter.MetronomeIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    *msg_matches_args: None | Container[Any] | Any,\n    **msg_matches_kwargs: (str, None | Container[Any] | Any)\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/midi_msg/","title":"Messages","text":""},{"location":"api/midi_msg/#midiscripter.MidiType","title":"<code>MidiType</code>","text":"<p>               Bases: <code>AttrEnum</code></p> <p>MIDI message type enumerator to use as <code>MidiMsg</code> <code>type</code> attribute</p>"},{"location":"api/midi_msg/#midiscripter.MidiType.NOTE_ON","title":"<code>NOTE_ON = 'NOTE_ON'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.NOTE_OFF","title":"<code>NOTE_OFF = 'NOTE_OFF'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.CONTROL_CHANGE","title":"<code>CONTROL_CHANGE = 'CONTROL_CHANGE'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.POLYTOUCH","title":"<code>POLYTOUCH = 'POLYTOUCH'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.AFTERTOUCH","title":"<code>AFTERTOUCH = 'AFTERTOUCH'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.PROGRAM_CHANGE","title":"<code>PROGRAM_CHANGE = 'PROGRAM_CHANGE'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.PITCH_BEND","title":"<code>PITCH_BEND = 'PITCH_BEND'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiType.SYSEX","title":"<code>SYSEX = 'SYSEX'</code>","text":""},{"location":"api/midi_msg/#midiscripter.MidiMsg","title":"MidiMsg","text":"<p>               Bases: <code>Msg</code></p> <p>The base class for MIDI messages that produces <code>ChannelMsg</code> or <code>SysexMsg</code> objects depending on init arguments.</p> <p>It is advised to use <code>ChannelMsg</code> or <code>SysexMsg</code> classes to create MIDI messages for clarity.</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg","title":"ChannelMsg","text":"<pre><code>ChannelMsg(\n    type: MidiType = MidiType.CONTROL_CHANGE,\n    channel: int = 1,\n    data1: int = 0,\n    data2: int = 64,\n    *,\n    combined_data: None | int = None,\n    source: None | MidiIn = None\n)\n</code></pre> <p>               Bases: <code>MidiMsg</code></p> <p>Channel voice/mode MIDI message. The most common MIDI message.</p> <p>Parameters:</p> <ul> <li> <code>type</code>               (<code>MidiType</code>, default:                   <code>CONTROL_CHANGE</code> )           \u2013            <p>MIDI message type</p> </li> <li> <code>channel</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>MIDI message channel (1-16)</p> </li> <li> <code>data1</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>First data byte: note, control, program or aftertouch value    depending on MIDI message type (0-127)</p> </li> <li> <code>data2</code>               (<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Second data byte: velocity, value depending on MIDI message type (0-127)</p> </li> <li> <code>combined_data</code>               (<code>None | int</code>, default:                   <code>None</code> )           \u2013            <p>Both data bytes combined to 14-bit number -            pitch value for pitch bend MIDI message (0-16383)</p> </li> <li> <code>source</code>               (<code>None | MidiIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>MidiIn</code> instance that generated the message</p> </li> </ul>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.source","title":"source","text":"<pre><code>source: None | MidiIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.type","title":"type","text":"<pre><code>type: MidiType\n</code></pre> <p>MIDI message type</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.channel","title":"channel","text":"<pre><code>channel: int = channel\n</code></pre> <p>MIDI message channel (1-16)</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.data1","title":"data1","text":"<pre><code>data1: int\n</code></pre> <p>First data byte: note, control, program or aftertouch value  depending on MIDI message type (0-127)</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.data2","title":"data2","text":"<pre><code>data2: int\n</code></pre> <p>Second data byte: velocity or value depending on MIDI message type (0-127)</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.combined_data","title":"combined_data","text":"<pre><code>combined_data: int | tuple[int, ...]\n</code></pre> <p>Both data bytes combined to 14-bit number - pitch value for pitch bend MIDI message (0-16383)</p>"},{"location":"api/midi_msg/#midiscripter.ChannelMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[MidiType] | MidiType = None,\n    channel: None | Container[int] | int = None,\n    data1: None | Container[int] | int = None,\n    data2: None | Container[int] | int = None,\n    *,\n    combined_data: None | Container[int] | int = None\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/midi_msg/#midiscripter.SysexMsg","title":"SysexMsg","text":"<pre><code>SysexMsg(combined_data: Sequence[int, ...], *, source: None | MidiIn = None)\n</code></pre> <p>               Bases: <code>MidiMsg</code></p> <p>System exclusive MIDI message</p> <p>Parameters:</p> <ul> <li> <code>combined_data</code>               (<code>Sequence[int, ...]</code>)           \u2013            <p>Whole sysex message including opening (<code>240</code>) and closing (<code>247</code>) bytes</p> </li> <li> <code>source</code>               (<code>None | MidiIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>MidiIn</code> instance that generated the message</p> </li> </ul>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.source","title":"source","text":"<pre><code>source: None | MidiIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.type","title":"type","text":"<pre><code>type = SYSEX\n</code></pre> <p>MIDI message type</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.channel","title":"channel","text":"<pre><code>channel: tuple[int, ...]\n</code></pre> <p>Manufacturer ID (protocol)</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.data1","title":"data1","text":"<pre><code>data1: tuple[int, ...]\n</code></pre> <p>Sub ID (model, device, command, etc.)</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.data2","title":"data2","text":"<pre><code>data2: tuple[int, ...]\n</code></pre> <p>Message data</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.combined_data","title":"combined_data","text":"<pre><code>combined_data: tuple[int, ...]\n</code></pre> <p>Whole sysex message including opening <code>240</code> and closing <code>247</code> bytes</p>"},{"location":"api/midi_msg/#midiscripter.SysexMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[MidiType] | MidiType = None,\n    channel: None | Container[tuple[int, ...]] | tuple[int, ...] = None,\n    data1: None | Container[tuple[int, ...]] | tuple[int, ...] = None,\n    data2: None | Container[tuple[int, ...]] | tuple[int, ...] = None,\n    *,\n    combined_data: None | Container[tuple[int, ...]] | tuple[int, ...] = None\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/midi_note_data/","title":"Utils","text":""},{"location":"api/midi_note_data/#midiscripter.NoteData","title":"NoteData","text":"<pre><code>NoteData(midi_note_or_name: int | str, use_flats: bool = False)\n</code></pre> <p>Optional wrapper for readable representation of MIDI note data</p> <p>Parameters:</p> <ul> <li> <code>midi_note_or_name</code>               (<code>int | str</code>)           \u2013            <p>MIDI note data (0-127) or note name (like 'C#3' or 'Db3')</p> </li> <li> <code>use_flats</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p><code>True</code> to use flats in note name (Db3), <code>False</code> to use sharps (C#3)</p> </li> </ul>"},{"location":"api/midi_note_data/#midiscripter.NoteData.middle_c_octave_n","title":"middle_c_octave_n","text":"<pre><code>middle_c_octave_n = 3\n</code></pre> <p>Octave number for middle C to use as reference for note naming</p>"},{"location":"api/midi_note_data/#midiscripter.NoteData.as_str","title":"as_str","text":"<pre><code>as_str() -&gt; str\n</code></pre> <p>Note name. Same as <code>str(note_data_obj)</code></p>"},{"location":"api/midi_note_data/#midiscripter.NoteData.as_int","title":"as_int","text":"<pre><code>as_int() -&gt; int\n</code></pre> <p>Note MIDI data. Same as <code>int(note_data_obj)</code></p>"},{"location":"api/midi_port/","title":"Ports","text":""},{"location":"api/midi_port/#midiscripter.MidiIO","title":"MidiIO","text":"<pre><code>MidiIO(port_name: str, *, virtual: bool = False, loopback: bool = False)\n</code></pre> <p>               Bases: <code>MultiPort</code></p> <p>MIDI input/output port that combines <code>MidiIn</code> and <code>MidiOut</code> ports with the same name. Produces and sends <code>MidiMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>port_name</code>               (<code>str</code>)           \u2013            <p>MIDI port name</p> </li> <li> <code>virtual</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create virtual input and output ports</p> </li> <li> <code>loopback</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Immediately send the messages received by the input port with the output port</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiIO.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/midi_port/#midiscripter.MidiIO.passthrough_out","title":"passthrough_out","text":"<pre><code>passthrough_out(midi_output: MidiOut) -&gt; None\n</code></pre> <p>Attach <code>MidiOut</code> as a pass-through port to send all incoming messages as soon as they arrive, before sending them to calls. This can greatly reduce latency.</p> <p>Parameters:</p> <ul> <li> <code>midi_output</code>               (<code>MidiOut</code>)           \u2013            <p><code>MidiOut</code> port to use for pass-through</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiIO.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container | MidiType = None,\n    channel: None | Container | int | tuple[int, ...] = None,\n    data1: None | Container | int | tuple[int, ...] = None,\n    data2: None | Container | int | tuple[int, ...] = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to all the wrapped inputs' messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiIO.send","title":"send","text":"<pre><code>send(msg: MidiMsg) -&gt; None\n</code></pre> <p>Send the MIDI message.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>MidiMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiIn","title":"MidiIn","text":"<pre><code>MidiIn(port_name: str, *, virtual: bool = False)\n</code></pre> <p>               Bases: <code>_MidiPortMixin</code>, <code>Input</code></p> <p>MIDI input port. Produces <code>MidiMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>port_name</code>               (<code>str</code>)           \u2013            <p>MIDI input port name</p> </li> <li> <code>virtual</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create virtual port</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/midi_port/#midiscripter.MidiIn.passthrough_out","title":"passthrough_out","text":"<pre><code>passthrough_out(midi_output: MidiOut) -&gt; None\n</code></pre> <p>Attach <code>MidiOut</code> as a pass-through port to send all incoming messages as soon as they arrive, before sending them to calls. This can greatly reduce latency.</p> <p>Parameters:</p> <ul> <li> <code>midi_output</code>               (<code>MidiOut</code>)           \u2013            <p><code>MidiOut</code> port to use for pass-through</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container | MidiType = None,\n    channel: None | Container | int | tuple[int, ...] = None,\n    data1: None | Container | int | tuple[int, ...] = None,\n    data2: None | Container | int | tuple[int, ...] = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiOut","title":"MidiOut","text":"<pre><code>MidiOut(port_name: str, *, virtual: bool = False)\n</code></pre> <p>               Bases: <code>_MidiPortMixin</code>, <code>Output</code></p> <p>MIDI output port. Sends <code>MidiMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>port_name</code>               (<code>str</code>)           \u2013            <p>MIDI output port name</p> </li> <li> <code>virtual</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create virtual port</p> </li> </ul>"},{"location":"api/midi_port/#midiscripter.MidiOut.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/midi_port/#midiscripter.MidiOut.send","title":"send","text":"<pre><code>send(msg: MidiMsg) -&gt; None\n</code></pre> <p>Send the MIDI message.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>MidiMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/midi_ports_changed/","title":"Midi Ports Watcher","text":""},{"location":"api/midi_ports_changed/#midiscripter.MidiPortsChangedIn","title":"MidiPortsChangedIn","text":"<pre><code>MidiPortsChangedIn()\n</code></pre> <p>               Bases: <code>Input</code></p> <p>MIDI ports change watcher. Produces base <code>Msg</code> objects. Used as a service port for GUI.</p>"},{"location":"api/midi_ports_changed/#midiscripter.MidiPortsChangedIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/midi_ports_changed/#midiscripter.MidiPortsChangedIn.refresh_rate_sec","title":"refresh_rate_sec","text":"<pre><code>refresh_rate_sec: float = 1\n</code></pre> <p>MIDI ports polling rate in seconds</p>"},{"location":"api/midi_ports_changed/#midiscripter.MidiPortsChangedIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    *msg_matches_args: None | Container[Any] | Any,\n    **msg_matches_kwargs: (str, None | Container[Any] | Any)\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/mouse_msg/","title":"Message","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent","title":"<code>MouseEvent</code>","text":"<p>               Bases: <code>AttrEnum</code></p> <p>Mouse event message type enumerator to use as <code>MouseMsg</code> <code>type</code> attribute</p>"},{"location":"api/mouse_msg/#midiscripter.MouseEvent.MOVE","title":"<code>MOVE = 'MOVE'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.LEFT_CLICK","title":"<code>LEFT_CLICK = 'LEFT_CLICK'</code>","text":"<p>Left button press and release. Not used by <code>MouseIn</code>  but can be sent with <code>MouseOut</code>.</p>"},{"location":"api/mouse_msg/#midiscripter.MouseEvent.MIDDLE_CLICK","title":"<code>MIDDLE_CLICK = 'MIDDLE_CLICK'</code>","text":"<p>Middle button press and release. Not used by <code>MouseIn</code>  but can be sent with <code>MouseOut</code>.</p>"},{"location":"api/mouse_msg/#midiscripter.MouseEvent.RIGHT_CLICK","title":"<code>RIGHT_CLICK = 'RIGHT_CLICK'</code>","text":"<p>Right button press and release. Not used by <code>MouseIn</code>  but can be sent with <code>MouseOut</code>.</p>"},{"location":"api/mouse_msg/#midiscripter.MouseEvent.LEFT_PRESS","title":"<code>LEFT_PRESS = 'LEFT_PRESS'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.MIDDLE_PRESS","title":"<code>MIDDLE_PRESS = 'MIDDLE_PRESS'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.RIGHT_PRESS","title":"<code>RIGHT_PRESS = 'RIGHT_PRESS'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.LEFT_RELEASE","title":"<code>LEFT_RELEASE = 'LEFT_RELEASE'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.MIDDLE_RELEASE","title":"<code>MIDDLE_RELEASE = 'MIDDLE_RELEASE'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.RIGHT_RELEASE","title":"<code>RIGHT_RELEASE = 'RIGHT_RELEASE'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.SCROLL_UP","title":"<code>SCROLL_UP = 'SCROLL_UP'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.SCROLL_DOWN","title":"<code>SCROLL_DOWN = 'SCROLL_DOWN'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.SCROLL_LEFT","title":"<code>SCROLL_LEFT = 'SCROLL_LEFT'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseEvent.SCROLL_RIGHT","title":"<code>SCROLL_RIGHT = 'SCROLL_RIGHT'</code>","text":""},{"location":"api/mouse_msg/#midiscripter.MouseMsg","title":"MouseMsg","text":"<pre><code>MouseMsg(type: MouseEvent, x: int, y: int, *, source: None | MouseIn = None)\n</code></pre> <p>               Bases: <code>Msg</code></p> <p>Keyboard event message</p> <p>Parameters:</p> <ul> <li> <code>type</code>               (<code>MouseEvent</code>)           \u2013            <p>Mouse event type</p> </li> <li> <code>x</code>               (<code>int</code>)           \u2013            <p>Event horizontal axis coordinates</p> </li> <li> <code>y</code>               (<code>int</code>)           \u2013            <p>Event vertical axis coordinates</p> </li> <li> <code>source</code>               (<code>None | MouseIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>MouseIn</code> instance that generated the message</p> </li> </ul> Tip <p>Run GUI and Enable mouse input. Use log to get mouse events you need.</p>"},{"location":"api/mouse_msg/#midiscripter.MouseMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/mouse_msg/#midiscripter.MouseMsg.type","title":"type","text":"<pre><code>type: MouseEvent\n</code></pre> <p>Mouse event type</p>"},{"location":"api/mouse_msg/#midiscripter.MouseMsg.x","title":"x","text":"<pre><code>x: int = x\n</code></pre> <p>Event horizontal screen coordinates</p>"},{"location":"api/mouse_msg/#midiscripter.MouseMsg.y","title":"y","text":"<pre><code>y: int = y\n</code></pre> <p>Event vertical screen coordinates</p>"},{"location":"api/mouse_msg/#midiscripter.MouseMsg.source","title":"source","text":"<pre><code>source: None | MouseIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/mouse_msg/#midiscripter.MouseMsg.matches","title":"matches","text":"<pre><code>matches(\n    type: None | Container[MouseEvent] | MouseEvent = None,\n    x: None | Container[int] | int = None,\n    y: None | Container[int] | int = None,\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/mouse_port/","title":"Ports","text":""},{"location":"api/mouse_port/#midiscripter.MouseIO","title":"MouseIO","text":"<pre><code>MouseIO()\n</code></pre> <p>               Bases: <code>MultiPort</code></p> <p>Mouse input/output port that combines <code>MouseIn</code> and <code>MouseOut</code> ports. Produces and sends <code>MouseMsg</code> objects.</p>"},{"location":"api/mouse_port/#midiscripter.MouseIO.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/mouse_port/#midiscripter.MouseIO.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[MouseEvent] | MouseEvent = None,\n    x: None | Container[int] | int = None,\n    y: None | Container[int] | int = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to all the wrapped inputs' messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/mouse_port/#midiscripter.MouseIO.send","title":"send","text":"<pre><code>send(msg: MouseMsg) -&gt; None\n</code></pre> <p>Send the mouse input.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>MouseMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/mouse_port/#midiscripter.MouseIn","title":"MouseIn","text":"<pre><code>MouseIn()\n</code></pre> <p>               Bases: <code>Input</code></p> <p>Mouse input port. Produces <code>MouseMsg</code> objects.</p> Warning <p>Transparent <code>MouseIn</code> -&gt; <code>MouseOut</code> proxy won't work, since it will react to its own output.</p> <p>Use <code>MouseOut</code> only for one-time movements.</p>"},{"location":"api/mouse_port/#midiscripter.MouseIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/mouse_port/#midiscripter.MouseIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    type: None | Container[MouseEvent] | MouseEvent = None,\n    x: None | Container[int] | int = None,\n    y: None | Container[int] | int = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/mouse_port/#midiscripter.MouseOut","title":"MouseOut","text":"<pre><code>MouseOut()\n</code></pre> <p>               Bases: <code>Output</code></p> <p>Mouse output port. Sends <code>MouseMsg</code> objects.</p> Warning <p>Transparent <code>MouseIn</code> -&gt; <code>MouseOut</code> proxy won't work, since it will react to its own output.</p> <p>Use <code>MouseOut</code> only for single movements.</p> <p>Parameters:</p> <ul> <li> <code>uid</code>               (<code>Hashable | None</code>, default:                   <code>None</code> )           \u2013            <p>Port's unique ID</p> </li> </ul>"},{"location":"api/mouse_port/#midiscripter.MouseOut.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/mouse_port/#midiscripter.MouseOut.send","title":"send","text":"<pre><code>send(msg: MouseMsg) -&gt; None\n</code></pre> <p>Send the mouse input.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>MouseMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/osc_msg/","title":"Message","text":""},{"location":"api/osc_msg/#midiscripter.OscMsg","title":"OscMsg","text":"<pre><code>OscMsg(\n    address: str,\n    data: str | bytes | bool | int | float | list | tuple = None,\n    *,\n    source: None | OscIn = None\n)\n</code></pre> <p>               Bases: <code>Msg</code></p> <p>Open Sound Control message</p> <p>Parameters:</p> <ul> <li> <code>address</code>               (<code>str</code>)           \u2013            <p>Open Sound Control message address</p> </li> <li> <code>data</code>               (<code>str | bytes | bool | int | float | list | tuple</code>, default:                   <code>None</code> )           \u2013            <p>Open Sound Control message data</p> </li> <li> <code>source</code>               (<code>None | OscIn</code>, default:                   <code>None</code> )           \u2013            <p>The <code>OscIn</code> instance that generated the message</p> </li> </ul>"},{"location":"api/osc_msg/#midiscripter.OscMsg.ctime","title":"ctime","text":"<pre><code>ctime: float\n</code></pre> <p>Message creation time in \"Unix time\" format</p>"},{"location":"api/osc_msg/#midiscripter.OscMsg.type","title":"type","text":"<pre><code>type: str = 'OSC'\n</code></pre> <p>Message type description for filtering and representation</p>"},{"location":"api/osc_msg/#midiscripter.OscMsg.address","title":"address","text":"<pre><code>address: str = address\n</code></pre> <p>Message address</p>"},{"location":"api/osc_msg/#midiscripter.OscMsg.data","title":"data","text":"<pre><code>data: str | bytes | bool | int | float | list | tuple = data\n</code></pre> <p>Message data</p>"},{"location":"api/osc_msg/#midiscripter.OscMsg.source","title":"source","text":"<pre><code>source: None | OscIn\n</code></pre> <p>Input port instance that generated the message</p>"},{"location":"api/osc_msg/#midiscripter.OscMsg.matches","title":"matches","text":"<pre><code>matches(\n    address: None | Container | str = None,\n    data: (\n        None | Container | str | bytes | bool | int | float | list | tuple\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Checks if message's attributes match all provided attribute conditions:</p> <ol> <li> <p>If condition is <code>None</code> or omitted, it matches anything.</p> </li> <li> <p>If condition equals attribute, it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the attribute, it matches the attribute.</p> </li> </ol> <p>Use <code>Not(condition)</code> to invert condition matching.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if all attributes match, <code>False</code> if any does not match</p> </li> </ul>"},{"location":"api/osc_port/","title":"Ports","text":""},{"location":"api/osc_port/#midiscripter.OscIO","title":"OscIO","text":"<pre><code>OscIO(input_listener_ip_port: str | int, output_target_ip_port: str | int)\n</code></pre> <p>               Bases: <code>MultiPort</code></p> <p>Open Sound Control input/output port that combines <code>OscIn</code> and <code>OscOut</code> ports. Produces and sends <code>OscMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>input_listener_ip_port</code>               (<code>str | int</code>)           \u2013            <p><code>'ip:port'</code> or local port to listen for incoming OSC messages</p> </li> <li> <code>output_target_ip_port</code>               (<code>str | int</code>)           \u2013            <p><code>'ip:port'</code> or local port to send output OSC messages to</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscIO.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/osc_port/#midiscripter.OscIO.query","title":"query","text":"<pre><code>query(\n    address: str,\n    data: str | bytes | bool | int | float | list | tuple = None,\n    *,\n    timeout_sec: float = 1\n) -&gt; str | bytes | bool | float | list | tuple\n</code></pre> <p>Queries data by sending the request to OSC address    and returns the data of response from that address</p> <p>Parameters:</p> <ul> <li> <code>address</code>               (<code>str</code>)           \u2013            <p>OSC address to send request to</p> </li> <li> <code>data</code>               (<code>str | bytes | bool | int | float | list | tuple</code>, default:                   <code>None</code> )           \u2013            <p>data to send request with, not used to match response</p> </li> <li> <code>timeout_sec</code>               (<code>float</code>, default:                   <code>1</code> )           \u2013            <p>time for response until raising <code>TimeoutError</code></p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TimeoutError</code>             \u2013            <p>on query timeout</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | bytes | bool | float | list | tuple</code>           \u2013            <p>Response OSC message data</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscIO.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    address: None | Container | str = None,\n    data: (\n        None | Container | str | bytes | bool | int | float | list | tuple\n    ) = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to all the wrapped inputs' messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscIO.send","title":"send","text":"<pre><code>send(msg: OscMsg) -&gt; None\n</code></pre> <p>Send the OSC message.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>OscMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscIn","title":"OscIn","text":"<pre><code>OscIn(listener_ip_port: str | int)\n</code></pre> <p>               Bases: <code>Input</code></p> <p>Open Sound Control input port. Produces <code>OscMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>listener_ip_port</code>               (<code>str | int</code>)           \u2013            <p><code>'ip:port'</code> or local port to listen for incoming OSC messages</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscIn.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/osc_port/#midiscripter.OscIn.subscribe","title":"subscribe","text":"<pre><code>subscribe(\n    address: None | Container | str = None,\n    data: (\n        None | Container | str | bytes | bool | int | float | list | tuple\n    ) = None,\n) -&gt; Callable\n</code></pre> <p>Decorator to subscribe a callable to the input's messages.</p> <p>Decorator without arguments subscribes a callable to all the input's messages.</p> <p>Decorator with arguments subscribes a callable to the input's messages that match conditions set by arguments. It works the same way as message's <code>matches</code> method:</p> <ol> <li> <p>If condition is <code>None</code> or omitted it matches anything.</p> </li> <li> <p>If condition equals the message's attribute value it matches the attribute.</p> </li> <li> <p>If condition is a container (list, tuple) and contains the message's attribute value, it matches the attribute.</p> </li> </ol> Examples <ol> <li>Calls function for all MIDI port's messages: <pre><code>@midi_input_instance.subscribe\ndef function(msg: MidiMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Calls function for OSC messages from specific address: <pre><code>@osc_input_instance.subscribe(address='/live/song/get/track_data')\ndef function(msg: OscMsg) -&gt; None:\n    pass\n</code></pre></li> <li>Call object instance method for MIDI port's \"note on\" and \"note off\" messages: <pre><code>midi_input_instance.subscribe((MidiType.NOTE_ON, MidiType.NOTE_OFF))(object.method)\n</code></pre></li> </ol> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Subscribed callable.</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscOut","title":"OscOut","text":"<pre><code>OscOut(target_ip_port: str | int)\n</code></pre> <p>               Bases: <code>Output</code></p> <p>Open Sound Control output port. Sends <code>OscMsg</code> objects.</p> <p>Parameters:</p> <ul> <li> <code>target_ip_port</code>               (<code>str | int</code>)           \u2013            <p><code>'ip:port'</code> or local port to send output OSC messages to</p> </li> </ul>"},{"location":"api/osc_port/#midiscripter.OscOut.is_opened","title":"is_opened","text":"<pre><code>is_opened: bool\n</code></pre> <p><code>True</code> if port is listening messages / ready to send messages</p>"},{"location":"api/osc_port/#midiscripter.OscOut.send","title":"send","text":"<pre><code>send(msg: OscMsg) -&gt; None\n</code></pre> <p>Send the OSC message.</p> <p>Parameters:</p> <ul> <li> <code>msg</code>               (<code>OscMsg</code>)           \u2013            <p>object to send</p> </li> </ul>"},{"location":"api/starters/","title":"Starters","text":""},{"location":"api/starters/#midiscripter.start_gui","title":"start_gui","text":"<pre><code>start_gui() -&gt; NoReturn\n</code></pre> <p>Starts the script and runs GUI. Logging goes to GUI Log widget</p>"},{"location":"api/starters/#midiscripter.start_silent","title":"start_silent","text":"<pre><code>start_silent() -&gt; NoReturn\n</code></pre> <p>Starts the script without logging. The fastest way to run the script</p>"},{"location":"api/starters/#midiscripter.start_cli_debug","title":"start_cli_debug","text":"<pre><code>start_cli_debug() -&gt; NoReturn\n</code></pre> <p>Starts the script with log output to console. Console prints increase latency and jitter. Use for debugging only.</p>"},{"location":"api/starters/#midiscripter.restart_script","title":"restart_script","text":"<pre><code>restart_script() -&gt; None\n</code></pre> <p>Restart the current script</p>"}]}