MIDI Scripter script has 5 main elements:

```python
from midiscripter import *

# 1. Ports
midi_keyboard = MidiIn('MIDI Keyboard')
proxy_output = MidiOut('To DAW')

# 2. GUI widgets (optional)
octave_selector = GuiButtonSelectorH(('-2', '-1', '0', '+1', '+2'), select='0')

# 3. Calls
@midi_keyboard.subscribe
def transpose(msg: MidiMsg) -> None:

# 4. Messages
    if msg.type == MidiType.NOTE_ON or msg.type == MidiType.NOTE_OFF:
        msg.data1 += 12 * int(octave_selector.selected_item_text)
        proxy_output.send(msg)

# 5. Starter
if __name__ == '__main__':
    start_gui() 
```

## 1. Ports

_Input ports_ are the sources and _output ports_ are a destination for 
_message_ objects.

_Ports_ are typically declared as `port_class(name_or_adress)`, except some 
that don't even need a name. Check specific ports description in API 
documentation.

_Port_ declaration line is all you need to use the port, the _starter_ 
function does the rest.

_Port_ declaration for unavailable MIDI port name will create a virtual port
(prepended with `[v]` in GUI) on Linux and macOS. On Windows you'll have to
use [loopMIDI](https://www.tobias-erichsen.de/software/loopmidi.html) to
create virtual ports manually. Virtual MIDI ports can be used to write proxy 
scripts, like the one above.

After the _starter_ opens all declared _ports_ the input _ports_ start to 
send _messages_ to subscribed _calls_.

_Calls_ or other Python code can use `output_port.send(msg)` to send 
messages.

Available ports: 
[MIDI](api/midi_port.md),
[OSC](api/osc_port.md),
[Keyboard](api/key_port.md),
[Metronome](api/metronome_port.md),
[File System Events](api/fs_port.md),
[Midi Ports Changes](api/midi_ports_changed.md).

## 2. GUI widgets (optional)

_GUI widgets_ declared in the script appear in GUI window opened
by [`start_gui`][midiscripter.start_gui] _starter_.

Widgets are declared as `widget_class(content, title = None, color = None)`
where:

- content - widget's text or tuple of items' text;
- title - optional widget title, by default the title is set by content;
- color - optional widget's text color.

Widget's initial state can be set by key value arguments specific for widget
class (`select`, `toggle_state`, etc.).

Widget's current state can be got or set by reading or changing its properties.

Check the widgets description in API documentation for declaration arguments and
properties of each widget.

_GUI widgets_ can be rearranged inside or even outside of GUI window by dragging
their titles.
The initial widget layout can be messy, but it's easy to arrange it as you want.
The GUI will save the widget layout for each script.

_GUI widgets_ act like input ports. They follow "one title - one instance" rule
and can have subscribed _calls_ that will
receive [`GuiEventMsg`][midiscripter.GuiEventMsg] _messages_.

Custom PySide6 widgets can be added to the GUI by `add_qwidget(qwidget)`.

Available widgets:
[GuiText][midiscripter.GuiText],
[GuiButton][midiscripter.GuiButton],
[GuiToggleButton][midiscripter.GuiToggleButton],
[GuiButtonSelectorH][midiscripter.GuiButtonSelectorH],
[GuiButtonSelectorV][midiscripter.GuiButtonSelectorV],
[GuiListSelector][midiscripter.GuiListSelector],
[GuiWidgetLayout][midiscripter.GuiWidgetLayout].


## 3. Calls

_Call_ is a function, an object method or anything callable that takes _message_
as the only argument. _Calls_ are not expected to return anything.

_Calls_ are subscribed to an input _port_ messages
by `@input_port_obj.subscribe` decorator. A single call can be subscribed to
multiple ports by multiple decorators:

``` python
@midi_in_port_obj_1.subscribe
@midi_in_port_obj_2.subscribe
def do_something(msg: MidiMsg) -> None:
    log.green('The call receives messages from both ports')
```

MIDI Scripter has it's own logger that can be used for _calls_ debugging or
feedback output. Print log messages with `log('message')`
or `log.red('colored message')`. Color methods
are `red`, `yellow`, `green`, `cyan`, `blue` and `magenta`.

Each _call_ runs in its own thread but all _calls_ run in the same process. If a
_call_ does some heavy computing it can increase latency and jitter for the
whole script. It's advised to move heavy computing out of the main process with
Python'
s [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html)
module.

Each _call_ receives its own copy of the input _message_ it can modify without
affecting other calls' work.

Getting exception in _call_ won't affect other _calls_ or the script's work.
Exception details are printed to log.

You can check _call_ execution time statistics in the Ports GUI widget by
hovering mouse over a call item.

## 4. Messages

_Messages_ are data objects generated by input _ports_ or created in the
script's code. _Messages_ can be sent with an output _port_ of the same type.

Each _message_ stores the source _port_ instance as `source` attribute and its
creation time in epoch format as `ctime` attribute.

The time since _message_ creation (in milliseconds) can be checked by
its `age_ms` attribute. You can use it for log messages.

[`MidiMsg`][midiscripter.MidiMsg] objects attributes meanings depending
on [MIDI message type][midiscripter.MidiType]:

| `type`                    | `channel`                                      | `data1`                         | `data2`                     | `combined_data`                      |
|---------------------------|------------------------------------------------|---------------------------------|-----------------------------|--------------------------------------|
| `MidiType.NOTE_ON`        | **Channel**<br>(1-16)                          | **Note**<br>(0-127)             | **Velocity**<br>(0-127)     | useless                              |
| `MidiType.NOTE_OFF`       | **Channel**<br>(1-16)                          | **Note**<br>(0-127)             | **Velocity**<br>(0-127)     | useless                              |
| `MidiType.CONTROL_CHANGE` | **Channel**<br>(1-16)                          | **Controller**<br>(0-127)       | **Value**<br>(0-127)        | useless                              |
| `MidiType.POLYTOUCH`      | **Channel**<br>(1-16)                          | **Note**<br>(0-127)             | **Pressure**<br>(0-127)     | useless                              |
| `MidiType.AFTERTOUCH`     | **Channel**<br>(1-16)                          | **Pressure**<br>(0-127)         | useless                     | useless                              |
| `MidiType.PROGRAM_CHANGE` | **Channel** <br>(1-16)                         | **Program**<br>(0-127)          | useless                     | useless                              |
| `MidiType.PITCH_BEND`     | **Channel**<br>(1-16)                          | useless                         | useless                     | **Pitch**<br>(0-16383)               |
| `MidiType.SYSEX`          | **Manufacturer ID** <br>(1 or 3 ints in tuple) | **Sub ID**<br>(2 ints in tuple) | **Data**<br>(ints in tuple) | **Whole message**<br>(ints in tuple) | 

The common attribute names and their defaults allows to safely change
message's `type`:

```python
# This type doesn't use the data2 attribute
>> > msg = ChannelMsg(MidiType.PROGRAM_CHANGE, 1, 10)

# But it still has the default value it doesn't use
>> > msg.data2
128

# So when you change its `type` the message is still valid to send
>> > msg.type = MidiType.CONTROL_CHANGE >> > msg
ChannelMsg(MidiType.CONTROL_CHANGE, 1, 10, 128)  
```

[OSC][midiscripter.OscMsg] and [keyboard messages][midiscripter.KeyMsg] are not
that complicated. They and other _message_ types are described in API
documentation.

Available message types: 
[MidiMsg][midiscripter.MidiMsg]
([ChannelMsg][midiscripter.ChannelMsg],
[SysexMsg][midiscripter.SysexMsg]),
[OscMsg][midiscripter.OscMsg],
[KeyMsg][midiscripter.KeyMsg],
[GuiEventMsg][midiscripter.GuiEventMsg],
[FileEventMsg][midiscripter.FileEventMsg],
[MidiPortsChangedIn][midiscripter.MidiPortsChangedIn].

## 5. Starter

_Starter_ is a function that should be called after _ports_, _widgets_ and
_calls_ are set up. _Starter_ opens all the _ports_, keeps input _message_
listening running and handles logging.

There are 3 _starter_ functions:

- [`start_gui`][midiscripter.start_gui] - starts the script with GUI and routes
  log messages to its Log widget. The preferred starter.
- [`start_silent`][midiscripter.start_silent] - starts the script with no logging
  or GUI. The fastest.
- [`start_cli_debug`][midiscripter.start_cli_debug] - starts the script with
  logging to console. That increases latency and jitter. Use only while
  debugging the script with no access to GUI.

## Combining multiple scripts

A single combined script is much easier to manage than running multiple
scripts in parallel.

Some ports can be opened only once by their design. To simplify ports management
_port_ declaration with the same name always returns the same _port_ object
instance (singleton):

``` python
>>> MidiIn('Port name') is MidiIn('Port name')
True
```

It's advised to put _starter_ into `if __name__ == '__main__':` clause, like in
the example scripts. It allows to safely combine standalone scripts later by
importing them:

```python
from midiscripter import *

# Scripts with starter in `if __name__ == '__main__':` are safe to import 
import my_first_script
import my_second_script

if __name__ == '__main__':
    # Uses setups from both scripts and runs them as a single script
    start_gui() 
```
