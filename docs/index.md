MIDI Scripter script consists of 5 main elements:

```python
from midiscripter import *

# 1. Ports
midi_keyboard = MidiIn('Port name')
proxy_output = MidiOut('loopMIDI Port')  

# 2. GUI widgets (optional)
octave_selector = GuiButtonSelectorH(('-2', '-1', '0', '+1', '+2'), select='0')

# 3. Calls
@midi_keyboard.subscribe
def transpose(msg: MidiMsg) -> None:
    
    # 4. Messages
	if msg.type == MidiType.NOTE_ON or msg.type == MidiType.NOTE_OFF:
         msg.data1 += 12 * int(octave_selector.selected_item_text)
         proxy_output.send(msg)

# 5. Starter
if __name__ == '__main__':  
     start_gui() 
```

## Ports
_Ports_ are sources and destinations of _messages_.

_Port_ declaration with the same name always returns the same _port_ object instance (singleton):

``` python
>>> MidiIn('Port name') is MidiIn('Port name')
True
```

The _starter_ opens all the ports, subscribed calls start to receive incoming messages.

To reduce the latency [`MidiIn`][midiscripter.MidiIn] _ports_ can be attached to pass-trough [`MidiOut`][midiscripter.MidiOut] _ports_ by `midi_in_port_obj.passthrough_out(midi_out_port_obj)`. Any MIDI _message_ will be passed to this pass-trough output _port_ before it's sent to _calls_.

## GUI widgets (optional)
_GUI widgets_ declared in the script appear in GUI window opened by [`start_gui`][midiscripter.start_gui] _starter_. 

Widgets are declared as `widget_class(content, title = None, color = None)` where:  
- content - widget's text or tuple of items text;  
- title - optional widget title, by default the title is set by content;  
- color - optional widget's text color.  

Widget's initial state can be set by key value arguments specific for widget class (`select`, `toggle_state`, etc.).

Widget's current state can be got or set by reading or changing its properties.

Check the widgets description in API documentation for declaration arguments and properties of each widget. 

_GUI widgets_ can be rearranged inside or even outside of GUI window by dragging their titles. 
The initial widget layout can be messy, but it's easy to arrange it as you want. 
The GUI will save the widget layout for each script.

_GUI widgets_ act like input ports. They follow "one title - one instance" rule and can have subscribed _calls_ that will receive [`GuiEventMsg`][midiscripter.GuiEventMsg] _messages_.

Custom PySide6 widgets can be added to the GUI by `add_qwidget(qwidget)`.

## Calls
_Call_ is a function, an object method or anything callable that takes _message_ as the only argument. _Calls_ are not expected to return anything.

_Calls_ are subscribed to an input _port_ messages by `@input_port_obj.subscribe` decorator. A single call can be subscribed to multiple ports by multiple decorators:

``` python
@midi_in_port_obj_1.subscribe
@midi_in_port_obj_2.subscribe
def do_something(msg: MidiMsg) -> None:
    log.green('The call receives messages from both ports')
```

MIDI Scripter has it's own logger that can be used for _calls_ debugging or feedback output. Print log messages with `log('message')` or `log.red('colored message')`. Color methods are `red`, `yellow`, `green`, `cyan`, `blue` and `magenta`.

Each _call_ runs in its own thread but all _calls_ run in the same process. If a _call_ does some heavy computing it can increase latency and jitter for the whole script. It's advised to move heavy computing out of the main process with Python's [`multiprocessing`](https://docs.python.org/3/library/multiprocessing.html) module.

Each _call_ receives its own copy of the input _message_ it can modify without affecting other calls' work.

Getting exception in _call_ won't affect other _calls_ or the script's work. Exception details are printed to log.

You can check _call_ execution time statistics in the Ports GUI widget by hovering mouse over a call item.

## Messages
_Messages_ are data objects generated by input _ports_ or created in the script's code. _Messages_ can be sent with an output _port_ of the same type.

Each _message_ stores the source _port_ instance as `source` attribute and its creation time in epoch format as `ctime` attribute. 

The time since _message_ creation (in milliseconds) can be checked by its `age_ms` attribute. You can use it for log messages.

[`MidiMsg`][midiscripter.MidiMsg] objects attributes meanings depending on [MIDI message type][midiscripter.MidiType]:

| `type`                    | `channel`                                       | `data1`                         | `data2`                      | `combined_data`                      |
|---------------------------|-------------------------------------------------|---------------------------------|------------------------------|--------------------------------------|
| `MidiType.NOTE_ON`        | **Channel**<br>(1-16)                           | **Note**<br>(0-127)             | **Velocity**<br>(0-127)      | useless                             |
| `MidiType.NOTE_OFF`       | **Channel**<br>(1-16)                           | **Note**<br>(0-127)             | **Velocity**<br>(0-127)          | useless                             |
| `MidiType.CONTROL_CHANGE` | **Channel**<br>(1-16)                           | **Controller**<br>(0-127)       | **Value**<br>(0-127)         | useless                             |
| `MidiType.POLYTOUCH`      | **Channel**<br>(1-16)                           | **Note**<br>(0-127)             | **Pressure**<br>(0-127)      | useless                             |
| `MidiType.AFTERTOUCH`     | **Channel**<br>(1-16)                           | **Pressure**<br>(0-127)         | useless                     | useless                             |
| `MidiType.PROGRAM_CHANGE` | **Channel** <br>(1-16)                          | **Program**<br>(0-127)          | useless                     | useless                             |
| `MidiType.PITCH_BEND`     | **Channel**<br>(1-16)                           | useless                         | useless                     | **Pitch**<br>(0-16383)               |
| `MidiType.SYSEX`          | **Manufacturer ID** <br>(1 or 3 ints in tuple) | **Sub ID**<br>(2 ints in tuple) | **Data**<br>(ints in tuple) | **Whole message**<br>(ints in tuple) | 

The common attribute names and their defaults allows to safely change message's `type`:
```python
# This type doesn't use the data2 attribute
>>> msg = ChannelMsg(MidiType.PROGRAM_CHANGE, 1, 10)  

# But it still has the default value it doesn't use
>>> msg.data2  
128

# So when you change its `type` the message is still valid to send
>>> msg.type = MidiType.CONTROL_CHANGE
>>> msg
ChannelMsg(MidiType.CONTROL_CHANGE, 1, 10, 128)  
```

[OSC][midiscripter.OscMsg] and [keyboard messages][midiscripter.KeyMsg] are not that complicated. They and other _message_ types are described in API documentation.

## Starter
_Starter_ is a function that should be called after _ports_, _widgets_ and _calls_ are set up. _Starter_ opens all the _ports_, keeps input _message_ listening running and handles logging.

There are 3 _starter_ functions:  
- `start_gui` - starts the script with GUI and routes log messages to its Log widget. The preferred starter.  
- `start_silent` - starts the script with no logging or GUI. The fastest.  
- `start_cli_debug` - starts the script with logging to console. That increases latency and jitter. Use only while debugging the script with no access to GUI.

It's advised to put _starter_ into `if __name__ == '__main__':` clause like in the example scripts. It allows to safely combine standalone scripts later by importing them:

```python
from midiscripter import *

# Scripts with starter in `if __name__ == '__main__':` are safe to import 
import my_first_script
import my_second_script

if __name__ == '__main__':  
    # Uses setups from both scripts and runs them as a single script
    start_gui() 
```

Most ports can be opened only once. It's not a MIDI Scripter limitation, it's a ports design limitation. So a single combined script is much easier to manage than running multiple scripts in parallel.
