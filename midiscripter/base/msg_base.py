import enum
from typing import TYPE_CHECKING, Any
from collections.abc import Container

import midiscripter.shared


if TYPE_CHECKING:
    from midiscripter.base.port_base import Input


class Not:
    def __init__(self, value: Container | Any):
        self.value = value


class AttrEnum(enum.StrEnum):
    def __repr__(self):
        return f'{self.__class__.__name__}.{self.value}'


class Msg:
    """The data object generated by input port that is sent as an argument to its subscribed calls
    and can be sent with an output port"""

    type: str
    """Message type description for filtering and representation"""

    ctime: float
    """Message creation time in ["Unix time"](https://wikipedia.org/wiki/Unix_time) format"""

    source: 'Input | None'
    """Input port instance that generated the message"""

    __match_args__: tuple[str] = ('type',)

    _gui_color: str = 'blue'
    _log_show_link: bool = True

    def __init__(self, type: str, source: 'Input | None' = None):
        """
        Args:
            source: Input port instance that generated the message
        """
        self.type = type
        self.source = source
        self.ctime = midiscripter.shared.precise_epoch_time()

        self.ctime: float  # workaround for mkdocstrings issue #607
        """Message creation time in ["Unix time"](https://wikipedia.org/wiki/Unix_time) format"""

    def __repr__(self):
        return f'{self.__class__.__name__}({", ".join(repr(value) for value in self._as_tuple())})'

    def __str__(self):
        return ' | '.join(str(value) for value in self._as_tuple() if value is not None)

    def __eq__(self, other_msg: 'Msg'):
        return type(self) is type(other_msg) and self._as_tuple() == other_msg._as_tuple()

    def matches(self, *conditions_args, **conditions_kwargs) -> bool:
        """Checks if message's attributes match all provided attribute conditions:

        1. If condition is `None` or omitted, it matches anything.

        2. If condition equals attribute, it matches the attribute.

        3. If condition is a container and contains the attribute, it matches the attribute.

        Use `Not(condition)` to invert condition matching.

        Returns:
            `True` if all attributes match, `False` if any does not match
        """
        attr_conditions = dict(zip(self.__match_args__, conditions_args, strict=False))
        attr_conditions.update(conditions_kwargs)

        for parameter_name, condition in attr_conditions.items():
            if condition is None:
                continue

            try:
                attr = getattr(self, parameter_name)
            except AttributeError:
                if isinstance(condition, Not):
                    continue
                else:
                    return False

            if attr == condition:
                if isinstance(condition, Not):
                    return False
                else:
                    continue

            try:
                if attr in condition and not isinstance(condition, str):
                    if isinstance(condition, Not):
                        return False
                    else:
                        continue
            except TypeError:  # condition is not a container
                pass

            return False
        return True

    @property
    def _age_ms(self) -> float:
        """Time passed since message creation in milliseconds"""
        # Using faster rounding
        return int((midiscripter.shared.precise_epoch_time() - self.ctime) * 1000000) / 1000

    def _as_tuple(self) -> tuple:
        """Converts message to a tuple based on message's __match_args__ class attribute

        Returns:
            Tuple with values of attributes specified in __match_args__ class attribute
        """
        return tuple(getattr(self, attr_name) for attr_name in self.__match_args__)
