import enum
from typing import Optional
from collections.abc import Container

import midiscripter.base.shared
from midiscripter.base.port_base import Input


class AttrEnum(enum.StrEnum):
    def __repr__(self):
        return f'{self.__class__.__name__}({self.value.__repr__()})'


class Msg:
    """The data object generated by input port that is sent as an argument to it's registered calls
    and can be sent with an output port."""

    type: str
    """Message type description for filtering and representation"""

    ctime: float
    """Message creation time in epoch format"""

    source: Input
    """Input port instance that generated the message."""

    __match_args__: tuple[str] = ('type',)

    def __init__(self, type: str, source: Input | None = None):
        """
        Args:
            source: Input port instance that generated the message
        """
        self.type = type
        self.source = source
        self.ctime = midiscripter.base.shared.precise_epoch_time()

        self.ctime: float  # workaround for mkdocstrings issue #607
        """Message creation time in epoch format"""

    def __repr__(self):
        return f'{self.__class__.__name__}({", ".join(str(value) for value in self.__as_tuple())})'

    def __str__(self):
        return ' | '.join(str(value) for value in self.__as_tuple() if value is not None)

    def __eq__(self, other_msg: 'Msg'):
        return type(self) is type(other_msg) and self.__as_tuple() == other_msg.__as_tuple()

    def matches(self, *args_conditions, **kwargs_conditions) -> bool:
        """Checks if message's attributes match all provided attribute conditions:
        1. If condition is `None` or omitted it matches anything.
        2. If condition equals attribute it matches the attribute.
        3. If condition is a container and contains the message attribute it matches the attribute.

        Returns:
            True if all attribute match, False if any are not
        """
        attr_conditions = dict(zip(self.__match_args__, args_conditions, strict=False))
        attr_conditions.update(kwargs_conditions)

        for parameter, condition in attr_conditions.items():
            if condition is None:
                continue

            try:
                attr = getattr(self, parameter)
            except AttributeError:
                continue

            if attr == condition:
                continue

            if (
                isinstance(condition, Container)
                and not isinstance(condition, str)
                and attr in condition
            ):
                continue

            return False
        return True

    @property
    def _age_ms(self) -> float:
        """Time passed since message creation in milliseconds."""
        return round((midiscripter.base.shared.precise_epoch_time() - self.ctime) * 1000, 3)

    def __as_tuple(self) -> tuple:
        """Converts message to a tuple based on message's __match_args__ class attribute

        Returns:
            Tuple with values of attributes specified in __match_args__ class attribute.
        """
        return tuple(getattr(self, attr_name) for attr_name in self.__match_args__)
